<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SpringCloud学习</title>
    <url>/2020/03/07/SpringCloud%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="SpringCloud学习"><a href="#SpringCloud学习" class="headerlink" title="SpringCloud学习"></a>SpringCloud学习</h1><h2 id="微服务介绍"><a href="#微服务介绍" class="headerlink" title="微服务介绍"></a>微服务介绍</h2><p>微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一一个的服务，彻底，<br>地去耦合每一个微服务提供单个业务功能的服务，一个服务做一-件事,<br>从技术角度看就是一种小而独立的处理过程，类似进程概能够自行单独启动<br>或销毁，拥有自己独立的数据库。</p>
<a id="more"></a>

<h3 id="微服务与微服务架构"><a href="#微服务与微服务架构" class="headerlink" title="微服务与微服务架构"></a>微服务与微服务架构</h3><h4 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h4><p>强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题/提供落地对应服务的一个服务应用,<br>狭意的看,可以看作Eclipse里面的一个个微服务工程/或者Module</p>
<h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><p>微服务架构是⼀种架构模式，它提倡将单⼀应⽤程序划分成⼀组⼩的服务，服务之间互相协调、互相配合，为⽤户提供最终价值。每个服务运⾏在其独⽴的进程中，服务与服务间采⽤轻量级的通信机制互相协作（通常是基于HTTP协议的RESTful API）。每个服务都围绕着具体业务进⾏构建，并且能够被独⽴的部署到⽣产环境、类⽣产环境等。另外，应当尽量避免统⼀的、集中式的服务管理机制，对具体的⼀个服务⽽⾔，应根据业务上下⽂，选择合适的语⾔、⼯具对其进⾏构建。</p>
<h3 id="微服务优缺点"><a href="#微服务优缺点" class="headerlink" title="微服务优缺点"></a>微服务优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>每个服务足够内聚，足够小，代码容易理解这样能聚焦一个指定的业务功能或业务需求<br>开发简单、开发效率提高，一个服务可能就是专一的只干一件事。<br>微服务能够被小团队单独开发，这个小团队是2到5人的开发人员组成。<br>微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。<br>微服务能使用不同的语言开发。<br>易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如Jenkins, Hudson, bamboo 。<br>微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。<br>微服务允许你利用融合最新技术。<br>微服务只是业务逻辑的代码，不会和HTML,CSS 或其他界面组件混合。<br>每个微服务都有自己的存储能力，可以有自己的数据库。也可以有统一数据库。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>开发人员要处理分布式系统的复杂性<br>多服务运维难度，随着服务的增加，运维的压力也在增大<br>系统部署依赖<br>服务间通信成本<br>数据一致性</p>
<h2 id="SpringCloud介绍"><a href="#SpringCloud介绍" class="headerlink" title="SpringCloud介绍"></a>SpringCloud介绍</h2><p>分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务栈解决方案。</p>
<h2 id="SpringCloud和SpringBoot的关系"><a href="#SpringCloud和SpringBoot的关系" class="headerlink" title="SpringCloud和SpringBoot的关系"></a>SpringCloud和SpringBoot的关系</h2><p>一个偏宏观，一偏微观<br>boot就是医院里面一个一个的科室，而Cloud就是把boot组合起来的提供对外的综合医院。<br>springboot可以单独使用，它不依赖于springcloud</p>
<ol>
<li>而springcloud必然依赖于springboot，属于依赖关系。</li>
<li>Springboot专注于快速方便的开发单个个体微服务。</li>
<li>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务。</li>
</ol>
<h2 id="SpringCloud和Dubbo的区别"><a href="#SpringCloud和Dubbo的区别" class="headerlink" title="SpringCloud和Dubbo的区别"></a>SpringCloud和Dubbo的区别</h2><table>
<thead>
<tr>
<th></th>
<th>Dubbo</th>
<th>Spring Cloud</th>
</tr>
</thead>
<tbody><tr>
<td>服务注册中心</td>
<td>Zookeeper</td>
<td>Spring Cloud Netflix Eureka</td>
</tr>
<tr>
<td>服务调用方式</td>
<td>RPC</td>
<td>REST API</td>
</tr>
<tr>
<td>服务监控</td>
<td>Dubbo-monitor</td>
<td>Spring Boot Admin</td>
</tr>
<tr>
<td>断路器</td>
<td>不完善</td>
<td>Spring Cloud Netflix Hystrix</td>
</tr>
<tr>
<td>服务网关</td>
<td>无</td>
<td>Spring Cloud Netflix Zuul</td>
</tr>
<tr>
<td>分布式配置</td>
<td>无</td>
<td>Spring Cloud Config</td>
</tr>
<tr>
<td>服务跟踪</td>
<td>无</td>
<td>Spring Cloud Sleuth</td>
</tr>
<tr>
<td>消息总线</td>
<td>无</td>
<td>Spring Cloud Bus</td>
</tr>
<tr>
<td>数据流</td>
<td>无</td>
<td>Spring Cloud Stream</td>
</tr>
<tr>
<td>批量任务</td>
<td>无</td>
<td>Spring Cloud Task</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p><strong>最大区别：SpringCloud抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式。</strong><br>严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更加合适。</p>
<h2 id="Springcloud参考网址"><a href="#Springcloud参考网址" class="headerlink" title="Springcloud参考网址"></a>Springcloud参考网址</h2><ol>
<li>官方网址：<a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener">https://spring.io/projects/spring-cloud</a></li>
<li>SpringCloud中国社区：<a href="http://springcloud.cn/" target="_blank" rel="noopener">http://springcloud.cn/</a></li>
<li>SpringCloud中文网：<a href="https://www.springcloud.cc/" target="_blank" rel="noopener">https://www.springcloud.cc/</a></li>
</ol>
<h2 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>RestTemplate提供了多种便捷访问远程Http服务的方法，<br>是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>创建一个ConfigBean文件做配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigBean</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为被spring容器掌管，需要添加@Configuration注解，说明此文件是配置文件相当于xml文件，然后就可以再消费者放使用Rest模板了</p>
<h3 id="消费者使用"><a href="#消费者使用" class="headerlink" title="消费者使用"></a>消费者使用</h3><h4 id="Get请求格式："><a href="#Get请求格式：" class="headerlink" title="Get请求格式："></a>Get请求格式：</h4><p>restTemplate.getForObject(url,返回值类型);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/consumer/dept/get/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Dept <span class="title">get</span><span class="params">()</span></span>&#123;  </span><br><span class="line">	<span class="keyword">return</span> restTemplate.getForObject(url+<span class="string">"/dept/get/"</span>+id,Dept<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h4><p>restTemplate.postForObject(url,参数,返回值类型);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/consumer/dept/add"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">add</span><span class="params">(Dept dept)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> restTemplate.postForObject(url+<span class="string">"/dept/add"</span>,dept,Boolean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h2><p><strong>Eureka</strong> 是 <strong>Netflix</strong> 开发的，一个基于 <strong>REST</strong> 服务的，服务注册与发现的组件</p>
<h3 id="AP原则"><a href="#AP原则" class="headerlink" title="AP原则"></a>AP原则</h3><p>Netflix在设计Eureka时遵循的是AP原则，而Zookeeper遵循的是CP原则</p>
<h4 id="CAP原则"><a href="#CAP原则" class="headerlink" title="CAP原则"></a>CAP原则</h4><p>CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可兼得</p>
<h3 id="Eureka架构图"><a href="#Eureka架构图" class="headerlink" title="Eureka架构图"></a>Eureka架构图</h3><p><img src="https://img-blog.csdnimg.cn/20200307205512997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>Eureka包含两个组件：Eureka Server和Eureka Client</p>
<h4 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h4><p>Eureka Server提供服务注册服务<br>各个节点启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到</p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><h6 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h6><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h6 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server: </span><br><span class="line">  port: <span class="number">7001</span></span><br><span class="line"> </span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost #eureka服务端的实例名称</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false #false表示不向注册中心注册自己。</span><br><span class="line">    fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/        #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。</span></span><br></pre></td></tr></table></figure>

<h6 id="主启动类"><a href="#主启动类" class="headerlink" title="主启动类"></a>主启动类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span><span class="comment">//EurekaServer服务器端启动类,接受其它微服务注册进来</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServer7001_App</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">   SpringApplication.run(EurekaServer7001_App<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Eureka-Client"><a href="#Eureka-Client" class="headerlink" title="Eureka Client"></a>Eureka Client</h4><p>EurekaClient是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）</p>
<h5 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h5><h6 id="pom-xml-1"><a href="#pom-xml-1" class="headerlink" title="pom.xml"></a>pom.xml</h6><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- 将微服务provider侧注册进eureka --&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h6 id="application-yml-1"><a href="#application-yml-1" class="headerlink" title="application.yml"></a>application.yml</h6><figure class="highlight"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client: #客户端注册进eureka服务列表内</span><br><span class="line">    service-url: </span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:7001/eureka</span></span><br><span class="line">  instance:</span><br><span class="line">    instance-id: microservicecloud-dept8001   #自定义服务名称信息</span><br><span class="line">    prefer-ip-address: true     #访问路径可以显示IP地址</span><br></pre></td></tr></table></figure>

<h6 id="主启动类-1"><a href="#主启动类-1" class="headerlink" title="主启动类"></a>主启动类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span> <span class="comment">//本服务启动后会自动注册进eureka服务中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptProvider8001_App</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">   SpringApplication.run(DeptProvider8001_App<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Eureka集群配置"><a href="#Eureka集群配置" class="headerlink" title="Eureka集群配置"></a>Eureka集群配置</h3><p>将之前的配置复制两遍</p>
<h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><h5 id="Server配置"><a href="#Server配置" class="headerlink" title="Server配置"></a>Server配置</h5><p>将原有的单机路径取消，配置上除了自己以外的集群类其它Eureka的路径</p>
<p>修改的配置如下：server端所有的yml文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eureka: </span><br><span class="line">  client: </span><br><span class="line">    service-url: </span><br><span class="line">      #单机 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/       #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。</span><br><span class="line">      # 这里取消单机，写除了自己以外集群内所有Eureka的路径</span><br><span class="line">      defaultZone: http:<span class="comment">//eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/</span></span><br></pre></td></tr></table></figure>

<h5 id="Client配置"><a href="#Client配置" class="headerlink" title="Client配置"></a>Client配置</h5><p>以前是单对单配置，客户端只需要配置自己需要Eureka的路径即可</p>
<p>修改yml文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client: #客户端注册进eureka服务列表内</span><br><span class="line">    service-url: </span><br><span class="line">      defaultZone: http:<span class="comment">//eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/</span></span><br></pre></td></tr></table></figure>

<h3 id="Eureka比Zookeeper"><a href="#Eureka比Zookeeper" class="headerlink" title="Eureka比Zookeeper"></a>Eureka比Zookeeper</h3><h4 id="作为服务注册中心，Eureka比Zookeeper好在哪里？"><a href="#作为服务注册中心，Eureka比Zookeeper好在哪里？" class="headerlink" title="作为服务注册中心，Eureka比Zookeeper好在哪里？"></a>作为服务注册中心，Eureka比Zookeeper好在哪里？</h4><p>著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性P在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。<br>因此<br>Zookeeper保证的是CP,<br>Eureka则是AP。</p>
<h4 id="Zookeeper保证CP"><a href="#Zookeeper保证CP" class="headerlink" title="Zookeeper保证CP"></a>Zookeeper保证CP</h4><p>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。</p>
<h4 id="Eureka保证AP"><a href="#Eureka保证AP" class="headerlink" title="Eureka保证AP"></a>Eureka保证AP</h4><p>Eureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况： </p>
<ol>
<li>Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 </li>
<li>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用) </li>
<li>当网络稳定时，当前实例新的注册信息会被同步到其它节点中</li>
</ol>
<p>因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。</p>
<h2 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h2><p> Ribbon是Netflix发布的云中间层服务开源项目，其主要功能是提供客户端实现负载均衡算法。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，Ribbon是一个客户端负载均衡器，我们可以在配置文件中Load Balancer后面的所有机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器，我们也很容易使用Ribbon实现自定义的负载均衡算法。</p>
<h3 id="LB（LoadBalanced）负载均衡"><a href="#LB（LoadBalanced）负载均衡" class="headerlink" title="LB（LoadBalanced）负载均衡"></a>LB（LoadBalanced）负载均衡</h3><h4 id="集中式LB"><a href="#集中式LB" class="headerlink" title="集中式LB"></a>集中式LB</h4><p>即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方。</p>
<h4 id="进程式LB"><a href="#进程式LB" class="headerlink" title="进程式LB"></a>进程式LB</h4><p>将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。</p>
<p><strong>Ribbon</strong>就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</p>
<h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><p>消费者端配置</p>
<h4 id="pom-xml-2"><a href="#pom-xml-2" class="headerlink" title="pom.xml"></a>pom.xml</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- Ribbon相关 --&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="ConfigBean"><a href="#ConfigBean" class="headerlink" title="ConfigBean"></a>ConfigBean</h4><p>在消费者端创建的config文件中，RestTemplate方法上添加@LoadBalanced</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="主启动类-2"><a href="#主启动类-2" class="headerlink" title="主启动类"></a>主启动类</h4><p>主启动类上添加@EnableEurekaClient注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(App80<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IRule"><a href="#IRule" class="headerlink" title="IRule"></a>IRule</h3><p>IRule提供了7种算法和自定义算法</p>
<h4 id="RoundRobinRule"><a href="#RoundRobinRule" class="headerlink" title="RoundRobinRule"></a>RoundRobinRule</h4><p>默认算法，轮询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">RoundRobinRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RoundRobinRule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RandomRule"><a href="#RandomRule" class="headerlink" title="RandomRule"></a>RandomRule</h4><p>随机</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">RandomRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AvailabilityFilteringRule"><a href="#AvailabilityFilteringRule" class="headerlink" title="AvailabilityFilteringRule"></a>AvailabilityFilteringRule</h4><p>会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，还有并发的连接数量超过阈值的服务，然后对剩余的服务列表按照轮询策略进行访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> IRule <span class="title">AvailabilityFilteringRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> AvailabilityFilteringRule();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="WeightedResponseTimeRule"><a href="#WeightedResponseTimeRule" class="headerlink" title="WeightedResponseTimeRule"></a>WeightedResponseTimeRule</h4><p>根据平均响应时间计算所有服务的权重，响应时间越快服务权重越大被选中的概率越高。刚启动时如果统计信息不足，则使用RoundRobinRule策略，等统计信息足够，会切换到WeightedResponseTimeRule</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> IRule <span class="title">WeightedResponseTimeRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> WeightedResponseTimeRule();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="RetryRule"><a href="#RetryRule" class="headerlink" title="RetryRule"></a>RetryRule</h4><p>先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试，获取可用的服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> IRule <span class="title">RetryRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> RetryRule();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="BestAvailableRule"><a href="#BestAvailableRule" class="headerlink" title="BestAvailableRule"></a>BestAvailableRule</h4><p>会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRule <span class="title">BestAvailableRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BestAvailableRule();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="ZoneAvoidanceRule"><a href="#ZoneAvoidanceRule" class="headerlink" title="ZoneAvoidanceRule"></a>ZoneAvoidanceRule</h4><p>默认规则,复合判断server所在区域的性能和server的可用性选择服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRule <span class="title">ZoneAvoidanceRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ZoneAvoidanceRule();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义算法"><a href="#自定义算法" class="headerlink" title="自定义算法"></a>自定义算法</h4><p>消费者端配置</p>
<h5 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h5><h6 id="主启动类-3"><a href="#主启动类-3" class="headerlink" title="主启动类"></a>主启动类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(name=<span class="string">"MICROSERVICECLOUD-DEPT"</span>,configuration=MySelfRule<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">App80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(App80<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="新建文件MySelfRule"><a href="#新建文件MySelfRule" class="headerlink" title="新建文件MySelfRule"></a>新建文件MySelfRule</h6><p><strong>注意</strong>：<br>官方文档明确给出了警告：<br>这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，<br>否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，也就是说<br>我们达不到特殊化定制的目的了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.IRule;</span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.RandomRule;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfRule</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();<span class="comment">//Ribbon默认是轮询，我自定义为随机</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis安装以及常用操作</title>
    <url>/2020/03/02/Redis%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="Redis安装以及常用操作"><a href="#Redis安装以及常用操作" class="headerlink" title="Redis安装以及常用操作"></a>Redis安装以及常用操作</h1><h2 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h2><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>
<a id="more"></a>

<h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><h3 id="Docker版"><a href="#Docker版" class="headerlink" title="Docker版"></a>Docker版</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure>

<h4 id="配置redis-conf"><a href="#配置redis-conf" class="headerlink" title="配置redis.conf"></a>配置redis.conf</h4><p>进入或者创建 /usr/local/docker/redis 目录下创建redis.conf</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/docker/redis</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/docker/redis/redis.conf</span><br></pre></td></tr></table></figure>

<blockquote>
<p>daemonize ： 默认为no，修改为yes启用守护线程<br>port ：设定端口号，默认为6379<br>bind ：绑定IP地址<br>databases ：数据库数量，默认16<br>save <second> <changes> ：指定多少时间、有多少次更新操作，就将数据同步到数据文件<br>#redis默认配置有三个条件，满足一个即进行持久化<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    save 900 1 #900s有1个更改<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        save 300 10 #300s有10个更改<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        save 60 10000 #60s有10000更改<br>dbfilename ：指定本地数据库的文件名，默认为dump.rdb<br>dir ：指定本地数据库的存放目录，默认为./当前文件夹<br>requirepass ：设置密码，默认关闭<br>redis -cli -h host -p port -a password</p>
</blockquote>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>启动redis服务</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-p</span> <span class="number">6379</span>:<span class="number">6379</span> <span class="literal">-v</span> /usr/local/docker/redis/redis.conf:/etc/redis/redis.conf <span class="literal">-v</span> /usr/local/docker/redis/<span class="keyword">data</span>:/<span class="keyword">data</span> -<span class="literal">-name</span> myredis <span class="literal">-d</span> redis</span><br></pre></td></tr></table></figure>

<p>进入redis</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker exec <span class="literal">-it</span> redisID /bin/bash</span><br></pre></td></tr></table></figure>
<p>运行redis</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis<span class="literal">-cli</span></span><br></pre></td></tr></table></figure>

<h3 id="Linux版"><a href="#Linux版" class="headerlink" title="Linux版"></a>Linux版</h3><p>后期更新</p>
<h3 id="Windows版"><a href="#Windows版" class="headerlink" title="Windows版"></a>Windows版</h3><p>后期更新，不推荐使用windows版，个人使用除外</p>
<h2 id="Redis常用操作"><a href="#Redis常用操作" class="headerlink" title="Redis常用操作"></a>Redis常用操作</h2><h3 id="Redis五大数据类型"><a href="#Redis五大数据类型" class="headerlink" title="Redis五大数据类型"></a>Redis五大数据类型</h3><p>Redis五种数据类型：string、hash、list、set、zset</p>
<h3 id="公用命令"><a href="#公用命令" class="headerlink" title="公用命令"></a>公用命令</h3><blockquote>
<p>DEL key<br>DUMP key：序列化给定key，返回被序列化的值<br>EXISTS key：检查key是否存在<br>EXPIRE key second：为key设定过期时间<br>TTL key：返回key剩余时间<br>PERSIST key：移除key的过期时间，key将持久保存<br>KEY pattern：查询所有符号给定模式的key<br>RANDOM key：随机返回一个key<br>RANAME key newkey：修改key的名称<br>MOVE key db：移动key至指定数据库中<br>TYPE key：返回key所储存的值的类型</p>
</blockquote>
<h3 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string(字符串)"></a>string(字符串)</h3><blockquote>
<p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。<br>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。<br>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p>
</blockquote>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><blockquote>
<p>setkey_name value：命令不区分大小写，但是key_name区分大小写<br>SETNX key value：当key不存在时设置key的值。（SET if Not eXists）<br>get key_name<br>GETRANGE key start end：获取key中字符串的子字符串，从start开始，end结束<br>MGET key1 [key2 …]：获取多个key<br>GETSET KEY_NAME VALUE：设定key的值，并返回key的旧值。当key不存在，返回nil<br>STRLEN key：返回key所存储的字符串的长度<br>INCR KEY_NAME ：INCR命令key中存储的值+1,如果不存在key，则key中的值话先被初始化为0再加1<br>INCRBY KEY_NAME 增量<br>DECR KEY_NAME：key中的值自减一<br>DECRBY KEY_NAME<br>append key_name value：字符串拼接，追加至末尾，如果不存在，为其赋值</p>
</blockquote>
<h3 id="hash（哈希）"><a href="#hash（哈希）" class="headerlink" title="hash（哈希）"></a>hash（哈希）</h3><p>Redis hash 是一个键值(key=&gt;value)对集合。</p>
<p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p>
<h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><blockquote>
<p>HSET key_name field value：为指定的key设定field和value<br>hmset key field value[field1,value1]<br>hget key field<br>hmget key field[field1]<br>hgetall key：返回hash表中所有字段和值<br>hkeys key：获取hash表所有字段<br>hlen key：获取hash表中的字段数量<br>-hdel key field [field1]：删除一个或多个hash表的字段</p>
</blockquote>
<h3 id="list（列表）"><a href="#list（列表）" class="headerlink" title="list（列表）"></a>list（列表）</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<h4 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h4><blockquote>
<p>lpush key value1 [value2]<br>rpush key value1 [value2]<br>lpushx key value：从左侧插入值，如果list不存在，则不操作<br>rpushx key value：从右侧插入值，如果list不存在，则不操作<br>llen key：获取列表长度<br>lindex key index：获取指定索引的元素<br>lrange key start stop：获取列表指定范围的元素<br>lpop key ：从左侧移除第一个元素<br>prop key：移除列表最后一个元素<br>blpop key [key1] timeout：移除并获取列表第一个元素，如果列表没有元素会阻塞列表到等待超时或发现可弹出元素为止<br>brpop key [key1] timeout：移除并获取列表最后一个元素，如果列表没有元素会阻塞列表到等待超时或发现可弹出元素为止<br>ltrim key start stop ：对列表进行修改，让列表只保留指定区间的元素，不在指定区间的元素就会被删除<br>lset key index value ：指定索引的值<br>linsert key before|after world value：在列表元素前或则后插入元素</p>
</blockquote>
<h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>Redis的Set是string类型的无序集合。<br>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
<h4 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h4><blockquote>
<p>sadd key value1[value2]：向集合添加成员<br>scard key：返回集合成员数<br>smembers key：返回集合中所有成员<br>sismember key member：判断memeber元素是否是集合key成员的成员<br>srandmember key [count]：返回集合中一个或多个随机数<br>srem key member1 [member2]：移除集合中一个或多个成员<br>spop key：移除并返回集合中的一个随机元素<br>smove source destination member：将member元素从source集合移动到destination集合<br>sdiff key1 [key2]：返回所有集合的差集<br>sdiffstore destination key1[key2]：返回给定所有集合的差集并存储在destination中</p>
</blockquote>
<h3 id="zset-sorted-set：有序集合"><a href="#zset-sorted-set：有序集合" class="headerlink" title="zset(sorted set：有序集合)"></a>zset(sorted set：有序集合)</h3><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。<br>zset的成员是唯一的,但分数(score)却可以重复。</p>
<h4 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h4><blockquote>
<p>ZADD key score1 memeber1<br>ZCARD key ：获取集合中的元素数量<br>ZCOUNT key min max 计算在有序集合中指定区间分数的成员数<br>ZCOUNT key min max 计算在有序集合中指定区间分数的成员数<br>ZRANK key member：返回有序集合指定成员的索引<br>ZREVRANGE key start stop ：返回有序集中指定区间内的成员，通过索引，分数从高到底<br>ZREM key member [member …] 移除有序集合中的一个或多个成员<br>ZREMRANGEBYRANK key start stop 移除有序集合中给定的排名区间的所有成员(第一名是0)(低到高排序）<br>ZREMRANGEBYSCORE key min max 移除有序集合中给定的分数区间的所有成员</p>
</blockquote>
<h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><p>Redis支持RDB和AOF两种持久化机制，持久化功能有效地避免因进程退出造成的数据丢失问题，当下次重启时利用之前持久化的文件即可实现数 据恢复。</p>
<h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发</p>
<h5 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h5><p>手动触发分别对应save和bgsave命令</p>
<p>save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存 比较大的实例会造成长时间阻塞，线上环境不建议使用</p>
<p>bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子 进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短</p>
<h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h5><p>使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改 时，自动触发bgsave。</p>
<p>如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点，更多细节见6.3节介绍的复制原理。<br>执行debug reload命令重新加载Redis时，也会自动触发save操作。</p>
<p>默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则 自动执行bgsave。</p>
<p>bgsave是主流的触发RDB持久化方式</p>
<h5 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h5><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><p>RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据 快照。非常适用于备份，全量复制等场景。比如每6小时执行bgsave备份， 并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。</p>
<p>Redis加载RDB恢复数据远远快于AOF的方式。</p>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><p>RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运 行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。</p>
<p>RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式 的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。</p>
<p>针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。</p>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF（append only file）持久化：以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用 是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式</p>
<h5 id="使用AOF"><a href="#使用AOF" class="headerlink" title="使用AOF"></a>使用AOF</h5><p>1.打开 redis.conf 文件，找到 APPEND ONLY MODE 对应内容，默认是关闭的，需要打开</p>
<blockquote>
<p>appendonly yes</p>
</blockquote>
<p>2.指定本地数据库文件名，默认值为 appendonly.aof</p>
<blockquote>
<p>appendfilename “appendonly.aof”</p>
</blockquote>
<p>3.指定更新日志条件</p>
<blockquote>
<p> #&nbsp;appendfsync always<br> appendfsync everysec<br> #&nbsp;appendfsync no</p>
</blockquote>
<p>always：同步持久化，每次发生数据变化会立刻写入到磁盘中。性能较差当数据完整性比较好（慢，安全）<br>everysec：出厂默认推荐，每秒异步记录一次（默认值）<br>no：不同步</p>
<p>4.配置重写触发机制</p>
<blockquote>
<p>auto-aof-rewrite-percentage 100<br>auto-aof-rewrite-min-size 64mb</p>
</blockquote>
<p>当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。</p>
<h5 id="AOF优缺点"><a href="#AOF优缺点" class="headerlink" title="AOF优缺点"></a>AOF优缺点</h5><h6 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h6><p>AOF可以更好的保护数据不丢失。</p>
<p>AOF日志文件以append-only模式写入，写入性能比较高。</p>
<p>AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。</p>
<p>适合做灾难性的误删除紧急恢复。</p>
<h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><p>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大，恢复速度慢。</p>
<p>AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1、不要仅仅使用RDB，因为那样会导致你丢失很多数据。</p>
<p>2、也不要仅仅使用AOF，因为那样有两个问题：<br>你通过AOF做冷备，没有RDB做冷备，恢复速度更快，<br>第二，RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制的bug。</p>
<p>3、综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择，<br>用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，还可以使用RDB来进行快速的数据恢复。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>可以一次执行多个命令，本质是一组命令的集合，一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其他命令插入，不许加塞</p>
<h4 id="事务常用命令"><a href="#事务常用命令" class="headerlink" title="事务常用命令"></a>事务常用命令</h4><blockquote>
<p>1.DISCARD：取消事务，放弃执行事务块内的所有命令<br>2.EXEC：执行所有事务块内的命令<br>3.MULTI：标记一个事务块的开始<br>4.UNWATCH：取消WATCH命令对所有key的监视<br>5.WATCH key [key…]：监视一个或多个key，如果在事务执行之前这个(些)key被其他命令所改动，那么事务被打断</p>
</blockquote>
<h4 id="WATCH"><a href="#WATCH" class="headerlink" title="WATCH"></a>WATCH</h4><p>Watch指令，类似乐观锁，事务提交时，如果key的值已被别的客户端改变，比如某个list已被别的客户端push/pop过了，整个事务队列都不会执行</p>
<p>通过watch命令在事务执行之前监控了多个key，倘若在watch之后有任何key的值发生了变化，EXEC命令执行的事务都将被放弃，同时返回Nullmulti-bulk应答以通知调用者事务执行失败</p>
<h4 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a>事务的错误处理</h4><p>1.如果队列中有命令输入错了，则整个队列都不会执行成功<br>2.如果队列中指令没有错，在执行过程中，指令执行失败，则只有当前指令失败，其它还是会成功</p>
<h4 id="事务的三个阶段"><a href="#事务的三个阶段" class="headerlink" title="事务的三个阶段"></a>事务的三个阶段</h4><p>1.开启事务<br><img src="https://img-blog.csdnimg.cn/20200302112454142.png" alt="在这里插入图片描述"><br>2.加入队列<br><img src="https://img-blog.csdnimg.cn/20200302112541502.png" alt="在这里插入图片描述"><br>3.执行事务<br><img src="https://img-blog.csdnimg.cn/20200302112622566.png" alt="在这里插入图片描述"></p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>1.单独的隔离操作：事务中的所有命令都会序列化，按顺序的执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>2.没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在“事务内的查询要看到事务里的更新，在事务外查询不能看到”这个问题。<br>3.不保证原子性：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。</p>
<h3 id="Redis消息发布订阅"><a href="#Redis消息发布订阅" class="headerlink" title="Redis消息发布订阅"></a>Redis消息发布订阅</h3><h4 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h4><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：<br><img src="https://img-blog.csdnimg.cn/20200302112942900.png" alt="在这里插入图片描述"><br>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：<br><img src="https://img-blog.csdnimg.cn/20200302112955404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="常用命令-5"><a href="#常用命令-5" class="headerlink" title="常用命令"></a>常用命令</h4><blockquote>
<p>subscribe channel [channel…]：订阅一个或多个频道的信息<br>psubscribe pattern [pattern…]：订阅一个或多个符合规定模式的频道<br>publish channel message ：将信息发送到指定频道<br>unsubscribe [channel[channel…]]：退订频道<br>punsubscribe [pattern[pattern…]]：退订所有给定模式的频道</p>
</blockquote>
<h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。</p>
<p>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p>
<h4 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h4><blockquote>
<p>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。<br>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。<br>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。<br>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p>
</blockquote>
<h4 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h4><p>一主二从指有一个主节点(master/leader)和两个从节点(slave/follower)</p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>开启三个redis镜像，外网访问端口分别是79,80,81</p>
<p>端口为79</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-p</span> <span class="number">6379</span>:<span class="number">6379</span> <span class="literal">-v</span> /usr/local/docker/redis/redis.conf:/etc/redis/redis.conf <span class="literal">-v</span> /usr/local/docker/redis/<span class="keyword">data</span>:/<span class="keyword">data</span> -<span class="literal">-name</span> myredis79 <span class="literal">-d</span> redis</span><br></pre></td></tr></table></figure>
<p>端口为80</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-p</span> <span class="number">6380</span>:<span class="number">6379</span> <span class="literal">-v</span> /usr/local/docker/redis/redis.conf:/etc/redis/redis.conf <span class="literal">-v</span> /usr/local/docker/redis/<span class="keyword">data</span>:/<span class="keyword">data</span> -<span class="literal">-name</span> myredis80 <span class="literal">-d</span> redis</span><br></pre></td></tr></table></figure>
<p>端口为81</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-p</span> <span class="number">6381</span>:<span class="number">6379</span> <span class="literal">-v</span> /usr/local/docker/redis/redis.conf:/etc/redis/redis.conf <span class="literal">-v</span> /usr/local/docker/redis/<span class="keyword">data</span>:/<span class="keyword">data</span> -<span class="literal">-name</span> myredis81 <span class="literal">-d</span> redis</span><br></pre></td></tr></table></figure>
<p>创建完成<br><img src="https://img-blog.csdnimg.cn/20200302114033147.png" alt="在这里插入图片描述"></p>
<p>设置端口为79的为主节点(master/leader)</p>
<p>需要先看79端口的ip地址可以用docker命令查看</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker inspect 镜像ID</span><br></pre></td></tr></table></figure>

<p>分别进入三个镜像</p>
<p>首先查看79端口的信息，用info replication查看当前79端口信息<br><img src="https://img-blog.csdnimg.cn/20200302114854194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">info replication</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200302114539922.png" alt="在这里插入图片描述"><br>默认显示79端口为主节点，没有从节点</p>
<p>80和81端口也是一样的</p>
<p>在将80和81端口设置为79端口的从节点，命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">SLAVEOF IP地址 端口号</span><br></pre></td></tr></table></figure>
<p>IP地址是刚才查看的79端口的ip地址：172.X.X.X<br>端口号是redis的外网查看端口号：6379<br><img src="https://img-blog.csdnimg.cn/20200302115117540.png" alt="在这里插入图片描述"><br>这样显示则显示连接成功，再去查看79端口信息<br><img src="https://img-blog.csdnimg.cn/2020030211522436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>80端口和81端口<br><img src="https://img-blog.csdnimg.cn/20200302115343346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>显示如下，则代表，一主二从配置成功</p>
<h4 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h4><p>上一个slave可以是下一个slave的Master，slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。</p>
<h5 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h5><p>79和80端口不变</p>
<p>81端口连接80端口</p>
<p>80端口显示如下<br><img src="https://img-blog.csdnimg.cn/20200302120055217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>显示自己还是从机，但自己算主机，79的从机，81的主机，这样减少了79的压力，但却添加了风险更大，如果80从机挂掉，则81也接受不到消息</p>
<h4 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h4><p>将从机升成主机</p>
<h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">SLAVEOF no one</span><br></pre></td></tr></table></figure>

<h5 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h5><p>假如79主机挂了，则正常情况，80和81都不会有所行动，这时需要挑选一个主机出来，控制从机。<br><img src="https://img-blog.csdnimg.cn/2020030212055249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这时，80端口就是主机了，79端口就算回来也不再是它们的主机</p>
<h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p>反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p>
<h5 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h5><p>79,80,81端口下， 自定义的/myredis目录下新建sentinel.conf文件（名字绝不能错），配置哨兵,填写内容</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">sentinel monitor ip地址 端口号 <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>上面最后一个数字1，表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机</p>
<h4 id="复制的缺点"><a href="#复制的缺点" class="headerlink" title="复制的缺点"></a>复制的缺点</h4><h5 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h5><p>因为读写分离，所有的写操作在主机上，传到从机上需要时间，当系统繁忙或者，访问量大的时候，延时时间将会更长，从机的数量越多，延时越严重</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker的安装以及使用</title>
    <url>/2020/02/28/Docker%E7%9A%84%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p>
<a id="more"></a>

<h2 id="Docker-的安装"><a href="#Docker-的安装" class="headerlink" title="Docker 的安装"></a>Docker 的安装</h2><p>1 如果有旧版本，建议先删除旧版本</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> sudo yum remove docker \</span><br><span class="line">                  docker<span class="literal">-client</span> \</span><br><span class="line">                  docker<span class="literal">-client</span><span class="literal">-latest</span> \</span><br><span class="line">                  docker<span class="literal">-common</span> \</span><br><span class="line">                  docker<span class="literal">-latest</span> \</span><br><span class="line">                  docker<span class="literal">-latest</span><span class="literal">-logrotate</span> \</span><br><span class="line">                  docker<span class="literal">-logrotate</span> \</span><br><span class="line">                  docker<span class="literal">-engine</span></span><br></pre></td></tr></table></figure>
<p>2.安装所需的软件包。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> sudo yum install <span class="literal">-y</span> yum<span class="literal">-utils</span> \</span><br><span class="line">  device<span class="literal">-mapper</span><span class="literal">-persistent</span><span class="literal">-data</span> \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure>
<p>3.使用以下命令来设置稳定的存储库。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> sudo yum<span class="literal">-config</span><span class="literal">-manager</span> \</span><br><span class="line">    -<span class="literal">-add</span><span class="literal">-repo</span> \</span><br><span class="line">    https://download.docker.com/linux/centos/docker<span class="literal">-ce</span>.repo</span><br></pre></td></tr></table></figure>

<p>4.可选：启用每晚或测试存储库。<br>    （1）启用每晚存储库。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> sudo yum<span class="literal">-config</span><span class="literal">-manager</span> -<span class="literal">-enable</span> docker<span class="literal">-ce</span><span class="literal">-nightly</span></span><br></pre></td></tr></table></figure>
<p> （2）启用测试通道。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> sudo yum<span class="literal">-config</span><span class="literal">-manager</span> -<span class="literal">-enable</span> docker<span class="literal">-ce</span><span class="literal">-test</span></span><br></pre></td></tr></table></figure>
<p>5.安装DOCKER ENGINE-社区</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> sudo yum install docker<span class="literal">-ce</span> docker<span class="literal">-ce</span><span class="literal">-cli</span> containerd.io</span><br></pre></td></tr></table></figure>
<p>6.启动Docker</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<p>7.测试Docker</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> sudo docker run hello<span class="literal">-world</span></span><br></pre></td></tr></table></figure>

<h2 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h2><h3 id="模型图"><a href="#模型图" class="headerlink" title="模型图"></a>模型图</h3><p><img src="https://img-blog.csdnimg.cn/20200228000639716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>Docker 利用容器（Container）独立运行的一个或一组应用。容器是用镜像创建的运行实例。</p>
<p>它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p>
<p>可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p>
<p>容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p>
<h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>仓库（Repository）是集中存放镜像文件的场所。</p>
<p>仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p>
<p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</p>
<p>最大的公开仓库是 Docker Hub(<a href="https://hub.docker.com/)，" target="_blank" rel="noopener">https://hub.docker.com/)，</a></p>
<p>存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云 等</p>
<h2 id="Docker是怎么工作的"><a href="#Docker是怎么工作的" class="headerlink" title="Docker是怎么工作的"></a>Docker是怎么工作的</h2><h3 id="模型图-1"><a href="#模型图-1" class="headerlink" title="模型图"></a>模型图</h3><p><img src="https://img-blog.csdnimg.cn/20200228000924221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱。</p>
<h2 id="Docker和VM"><a href="#Docker和VM" class="headerlink" title="Docker和VM"></a>Docker和VM</h2><h3 id="模型图对比"><a href="#模型图对比" class="headerlink" title="模型图对比"></a>模型图对比</h3><p><img src="https://img-blog.csdnimg.cn/20200228001014347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200228001023297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="Docker为什么比VM快"><a href="#Docker为什么比VM快" class="headerlink" title="Docker为什么比VM快"></a>Docker为什么比VM快</h3><p>(1)docker有着比虚拟机更少的抽象层。由亍docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p>
<p>(2)docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。</p>
<h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><ol>
<li>docker version ： 获取docker的版本号</li>
<li>docker info : 显示 Docker 系统信息，包括镜像和容器数</li>
<li>docker –help : docker的全部命令</li>
</ol>
<h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><ol>
<li>docker images : 列出本地实例</li>
<li>docker search : 在hub上搜索镜像  例子：docker search tomcat</li>
<li>docker pull : 在hub上下载镜像 例子：docker pull tomcat</li>
<li>docker rmi : 删除本地镜像 例子：docker rmi -f tomcat</li>
<li>docker rmi : 删除多个 例子：docker rmi -f tomcat centos</li>
<li>docker rmi : 删除所有 例子：docker rmi -f $(docker images -qa)</li>
<li>docker commit：提交容器副本，使之成为一个新的镜像 例子：docker commit -a=”作者” -m=”描述” 容器ID 要创建的目标镜像名:TAR</li>
</ol>
<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><ol>
<li>docker run ：新建并且启动容器 例子：docker run tomcat</li>
<li>docker ps : 列出所有在运行的容器</li>
<li>exit : 退出容器停止容器</li>
<li>ctrl+p+q ：容器不停止退出容器</li>
<li>docker start : 启动容器 例子：docker start 容器ID或者容器名</li>
<li>docker restart ：重启容器 例子：docker restart 容器ID或者容器名</li>
<li>docker stop ：停止容器 例子：docker stop 容器ID或者容器名</li>
<li>docker kill：强制停止容器 例子：docker kill 容器ID或者容器名</li>
<li>docker rm ：删除已停止的容器 例子：docker rm -f 容器ID或者容器名</li>
<li>docker run -d ：以守护进程的方式启动 例子：docker run -d tomcat</li>
<li>docker run –it ：一交互式进程的方式启动 例子：docker run -it tomcat</li>
<li>docker top ：查看容器内运行的进程 例子：docker top 容器ID或者容器名</li>
<li>docker inspect ：查看容器内部细节 例子：docker inspect 容器ID或者容器名</li>
<li>docker exec：进入正在运行的容器中 例子：docker exec -d/it 容器ID或者容器名</li>
<li>docker attach ：重新进入容器 例子：docker attach 容器ID或者容器名</li>
<li>docker cp ：将容器内地文件拷贝的主机上 例子：docker cp 容器ID:容器内的路径 主机的路径</li>
</ol>
<h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><h3 id="UnionFS（联合文件系统）"><a href="#UnionFS（联合文件系统）" class="headerlink" title="UnionFS（联合文件系统）"></a>UnionFS（联合文件系统）</h3><p>Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p>一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>
<h3 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h3><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p>
<p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p>
<p>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。<br><img src="https://img-blog.csdnimg.cn/20200228003050705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？<br> <img src="https://img-blog.csdnimg.cn/20200228003106332.png" alt="在这里插入图片描述"><br>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p>
<h3 id="分层的镜像"><a href="#分层的镜像" class="headerlink" title="分层的镜像"></a>分层的镜像</h3><p>以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载<br><img src="https://img-blog.csdnimg.cn/20200228003145393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><h4 id="共享资源"><a href="#共享资源" class="headerlink" title="共享资源"></a>共享资源</h4><p> 比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，</p>
<p>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>Docker镜像都是只读的，当容器启动时，一个新的可写成被加载到镜像的顶部，这一次通常被称作”容器层”,”容器层”之下的都叫”镜像层”。</p>
<h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><h3 id="Docker的理念"><a href="#Docker的理念" class="headerlink" title="Docker的理念"></a>Docker的理念</h3><ul>
<li><p>将运用与运行的环境打包形成容器运行 ，运行可以伴随着容器，但是我们对数据的要求希望是持久化的</p>
</li>
<li><p>容器之间希望有可能共享数据</p>
</li>
<li><p>Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据做为镜像的一部分保存下来，那么当容器删除后，数据自然也就没有了。</p>
</li>
<li><p>为了能保存数据在docker中我们使用卷。</p>
</li>
</ul>
<h3 id="卷"><a href="#卷" class="headerlink" title="卷"></a>卷</h3><p> 卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：</p>
<p> 卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷 </p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>1：数据卷可在容器之间共享或重用数据</p>
<p>2：卷中的更改可以直接生效</p>
<p>3：数据卷中的更改不会包含在镜像的更新中</p>
<p>4：数据卷的生命周期一直持续到没有容器使用它为止</p>
<h3 id="数据卷添加"><a href="#数据卷添加" class="headerlink" title="数据卷添加"></a>数据卷添加</h3><h4 id="命令添加"><a href="#命令添加" class="headerlink" title="命令添加"></a>命令添加</h4><p>docker run -it -v 主机路径:容器内路径 容器ID或者容器名 /bin/bash</p>
<h4 id="DockerFile添加"><a href="#DockerFile添加" class="headerlink" title="DockerFile添加"></a>DockerFile添加</h4><ol>
<li>创建一个文件  mydockerfile</li>
<li>编写mydockerfile文件</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># volume test</span></span><br><span class="line"></span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">VOLUME [<span class="string">"/dataVolumeContainer1"</span>,<span class="string">"/dataVolumeContainer2"</span>]</span><br><span class="line"></span><br><span class="line">CMD echo <span class="string">"finished,--------success1"</span></span><br><span class="line"></span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>build成一个新的镜像   例子：docker build -f 文件路径 -t 镜像名</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker build <span class="operator">-f</span> /mydocker/mydockerfile <span class="literal">-t</span> /victoria/centos</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>执行容器</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-it</span> /victoria/centos</span><br></pre></td></tr></table></figure>

<h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器</p>
<h3 id="容器间传递共享"><a href="#容器间传递共享" class="headerlink" title="容器间传递共享"></a>容器间传递共享</h3><ol>
<li>先创建并且启动一个父容器 </li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-it</span> -<span class="literal">-name</span> dc01 victoria/centos</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建子容器继承父容器  例子： docker  –volumes-from 父容器</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-it</span> -<span class="literal">-name</span> dc02 -<span class="literal">-volumes</span><span class="literal">-from</span> dc01 victoria/centos</span><br></pre></td></tr></table></figure>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p> 容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止</p>
<h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><h3 id="DockerFile是什么"><a href="#DockerFile是什么" class="headerlink" title="DockerFile是什么"></a>DockerFile是什么</h3><p>DockerFile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。</p>
<h3 id="DockerFile构建的步骤"><a href="#DockerFile构建的步骤" class="headerlink" title="DockerFile构建的步骤"></a>DockerFile构建的步骤</h3><ol>
<li>编写DockerFile文件</li>
<li>docker build</li>
<li>docker run</li>
</ol>
<h3 id="Docker内容基础知识"><a href="#Docker内容基础知识" class="headerlink" title="Docker内容基础知识"></a>Docker内容基础知识</h3><ol>
<li>每条保留字指令都必须为答谢字母且后面要跟随至少一个参数</li>
<li>指令按照从上到下，顺序执行</li>
<li>#表示注释</li>
<li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li>
</ol>
<h3 id="Docker执行DockerFile大致流程"><a href="#Docker执行DockerFile大致流程" class="headerlink" title="Docker执行DockerFile大致流程"></a>Docker执行DockerFile大致流程</h3><ol>
<li>docker从基础镜像运行一个容器</li>
<li>执行一条指令并对容器作出修改</li>
<li>执行类似docker commit的操作提交一个新的镜像层</li>
<li>docker再基于刚提交的镜像运行一个新容器</li>
<li>执行dockerfile中的下一条指令直到所有指令都执行完成</li>
</ol>
<h3 id="DockerFile保留字"><a href="#DockerFile保留字" class="headerlink" title="DockerFile保留字"></a>DockerFile保留字</h3><table>
<thead>
<tr>
<th>保留字</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>基础镜像，当前新镜像是基于哪个镜像的</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>镜像维护者的姓名和邮箱地址</td>
</tr>
<tr>
<td>RUN</td>
<td>容器构建时需要运行的命令</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>当前容器对外暴露出的端口</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>指定在创建容器后，终端默认的进来工作目录，一个落脚点</td>
</tr>
<tr>
<td>ENV</td>
<td>用来在构建镜像过程中设置环境变量</td>
</tr>
<tr>
<td>ADD</td>
<td>将主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</td>
</tr>
<tr>
<td>COPY</td>
<td>类似ADD，拷贝文件和目录到镜像中</td>
</tr>
<tr>
<td>VOLUME</td>
<td>容器数据卷，用于数据保存和持久化工作</td>
</tr>
<tr>
<td>CMD</td>
<td>指定一个容器启动时要运行的命令，DockerFile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>指定一个容器启动时要运行的命令，ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数，但不会被docker run之后的参数替换</td>
</tr>
<tr>
<td>ONBUILD</td>
<td>当创建一个被继承的DockerFile时运行命令，父镜像在被子镜像继承后父镜像的onbuild被触发</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池的核心参数以及执行流程</title>
    <url>/2020/02/24/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><a id="more"></a>

<h2 id="线程池类型"><a href="#线程池类型" class="headerlink" title="线程池类型"></a>线程池类型</h2><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大<br>多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，<br>则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何<br>线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之<br>前，池中的线程将一直存在。</p>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行<br>很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造<br>的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并<br>从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资<br>源。</p>
<h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>返回一个只有一个线程的线程池,这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去！</p>
<h2 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h2><h3 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h3><p>核心线程数，该参数说明了在线程池中保持核心线程的数量，由自己定义，刚创建线程池时，里面的核心线程数为0，随着任务的添加，达到核心线程数，执行完任务之后，线程池里面的核心线程数一直维持在设置的核心线程数。</p>
<h3 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h3><p>最大线程数，该参数定义了一个线程池中最多能容纳多少个线程。当一个任务提交到线程池中时，如果线程数量达到了核心线程数，并且任务队列已满，不能再向任务队列中添加任务时，这时会检查任务是否达到了最大线程数，如果未达到，则创建新线程，执行任务，否则，执行拒绝策略。</p>
<h3 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h3><p>（最大线程数—核心线程数）线程存活时间，线程池中大于核心线程数的那部分线程，即线程数总数量减去核心线程数的那部分线程，在执行完任务之后，在线程池中存活的时间。</p>
<h3 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h3><p>任务队列，用来做缓冲作用，当提交到线程池中的任务核心线程数量不够用时，所有的核心线程都在执行任务，会将任务存到任务队列中，等待核心线程来执行。该参数主要是在核心线程数都在执行任务时，才起作用的参数，主要用来缓存任务。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://img-blog.csdnimg.cn/20200224204540127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h3><p>用户提交任务，查看核心线程池是否满，没满则创建线程，执行任务，<br>满了则交给缓冲队列，缓冲队列没满，则将任务添加到队列，满了，则<br>判断最大线程池是否满了，没满则创建线程，执行任务，满了则拒绝策略</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ拓展</title>
    <url>/2020/02/16/RabbitMQ%E6%8B%93%E5%B1%95/</url>
    <content><![CDATA[<h1 id="RabbitMQ拓展"><a href="#RabbitMQ拓展" class="headerlink" title="RabbitMQ拓展"></a>RabbitMQ拓展</h1><a id="more"></a>

<h2 id="TTL队列-消息"><a href="#TTL队列-消息" class="headerlink" title="TTL队列/消息"></a>TTL队列/消息</h2><ol>
<li>TTL是Time To Live的缩写, 也就是生存时间</li>
<li>RabbitMQ支持消息的过期时间, 在消息发送时可以进行指定</li>
<li>RabbitMQ支持队列的过期时间, 从消息入队列开始计算, 只要超过了队列的超时时间配置, 那么消息会自动清除</li>
</ol>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"test_exchange_ttl"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//交换机声明</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"topic"</span>,<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//路由键</span></span><br><span class="line">        String rount_key = <span class="string">"user.add"</span>;</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            String msg_str = <span class="string">"Hello TTl msg"</span>+i;</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME,rount_key,<span class="keyword">null</span>,msg_str.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭链接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"test_exchange_ttl"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"test_queue_ttl"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//限流</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//配置参数</span></span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        <span class="comment">//配置ttl过期时间</span></span><br><span class="line">        map.put(<span class="string">"x-message-ttl"</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="comment">//声明队列和交换机</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,map);</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"topic"</span>,<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//路由键匹配</span></span><br><span class="line">        String rount_key = <span class="string">"user.#"</span>;</span><br><span class="line">        <span class="comment">//队列绑定交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,rount_key);</span><br><span class="line">        <span class="comment">//消费者</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(body));</span><br><span class="line">                <span class="comment">//ack认证</span></span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="DLX-死信队列"><a href="#DLX-死信队列" class="headerlink" title="DLX(死信队列)"></a>DLX(死信队列)</h2><ol>
<li>Dead-Letter-Exchange</li>
<li>利用DLX, 当消息在一个队列中变成死信(dead message)之后, 它能被重新publish到另一个Exchange, 这个Exchange就是DLX</li>
<li>DLX也是一个正常的Exchange, 和一般的Exchange没有区别, 它能在任何队列上被指定, 实际上就是设置某个队列的属性为死信队列</li>
<li>当这个队列中有死信时, RabbitMQ就会自动将这个消息重新发布到设置的Exchange上去, 进而被路由到另一个队列</li>
<li>可以监听这个队列中消息做相应的处理, 这个特性可以弥补RabbitMQ3.0以前支持的immediate参数的功能</li>
</ol>
<h3 id="消息变成死信队列的几种情况"><a href="#消息变成死信队列的几种情况" class="headerlink" title="消息变成死信队列的几种情况"></a>消息变成死信队列的几种情况</h3><ol>
<li>消息被拒绝(basic.reject/basic.nack) 并且requeue重回队列设置成false</li>
<li>消息TTL过期</li>
<li>队列达到最大长度</li>
</ol>
<h3 id="死信队列的配置"><a href="#死信队列的配置" class="headerlink" title="死信队列的配置"></a>死信队列的配置</h3><ol>
<li>首先要设置死信队列的exchange和queue,然后进行绑定（死信队列的交换机名和队列名只能这样写）<pre><code> **1.Exchange : dlx.exchange
2.Queue : dlx.queue
3.RoutingKey : #**</code></pre></li>
<li>然后正常声明交换机, 队列, 绑定, 只不过需要在队列加上一个扩展参数即可 : arguments.put(“x-dead-letter-exchange”, “dlx.exchange”);</li>
<li>这样消息在过期, reject或nack(requeue要设置成false), 队列在达到最大长度时, 消息就可以直接路由到死信队列</li>
</ol>
<h3 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.AMQP;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"test_exchange_dlx"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//路由键</span></span><br><span class="line">        String rount_key = <span class="string">"user.add"</span>;</span><br><span class="line">        <span class="comment">//消息十秒没被消费则过期</span></span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties().builder().expiration(<span class="string">"10000"</span>).build();</span><br><span class="line">        <span class="comment">//生产者发送消息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            String str_msg = <span class="string">"hello dlx msg"</span>+i;</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME,rount_key,properties,str_msg.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭链接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"test_exchange_dlx"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"test_queue_dlx"</span>;</span><br><span class="line">    <span class="comment">//注意：死信队列的交换机名和队列名只能这样取</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_DLX_NAME = <span class="string">"dlx.exchange"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_DLX_NAME = <span class="string">"dlx.queue"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//限流</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//定义死信队列的队列和交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_DLX_NAME,<span class="string">"topic"</span>,<span class="keyword">true</span>);</span><br><span class="line">        channel.queueDeclare(QUEUE_DLX_NAME,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//绑定</span></span><br><span class="line">        channel.queueBind(QUEUE_DLX_NAME,EXCHANGE_DLX_NAME,<span class="string">"#"</span>);</span><br><span class="line">        <span class="comment">//定义交换机和队列</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"topic"</span>,<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//给与死信队列配置</span></span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">"x-dead-letter-exchange"</span>,EXCHANGE_DLX_NAME);</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,map);</span><br><span class="line">        <span class="comment">//路由键</span></span><br><span class="line">        String rount_key = <span class="string">"user.#"</span>;</span><br><span class="line">        <span class="comment">//绑定</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,rount_key);</span><br><span class="line">        <span class="comment">//消费者消费消息</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(body));</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC流程</title>
    <url>/2020/02/16/SpringMVC%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h1><h2 id="SpringMVC介绍"><a href="#SpringMVC介绍" class="headerlink" title="SpringMVC介绍"></a>SpringMVC介绍</h2><p>Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的Spring MVC框架或集成其他MVC开发框架。</p>
<a id="more"></a>

<h2 id="SpringMVC核心组件"><a href="#SpringMVC核心组件" class="headerlink" title="SpringMVC核心组件"></a>SpringMVC核心组件</h2><h3 id="DispatcherServlet-前置控制器"><a href="#DispatcherServlet-前置控制器" class="headerlink" title="DispatcherServlet(前置控制器)"></a>DispatcherServlet(前置控制器)</h3><p>DispatcherServlet是前置控制器，配置在web.xml文件中的。拦截匹配的请求，Servlet拦截匹配规则要自己定义，把拦截下来的请求，依据相应的规则分发到目标Controller来处理，是配置spring MVC的第一步。</p>
<h3 id="Handler（处理器）"><a href="#Handler（处理器）" class="headerlink" title="Handler（处理器）"></a>Handler（处理器）</h3><p>可以理解成Conroller（控制器）</p>
<h3 id="HandlerMapping（处理器映射器）"><a href="#HandlerMapping（处理器映射器）" class="headerlink" title="HandlerMapping（处理器映射器）"></a>HandlerMapping（处理器映射器）</h3><p>作用是根据当前请求的找到对应的 Handler，并将 Handler（执行程序）与一堆 HandlerInterceptor（拦截器）封装到 HandlerExecutionChain 对象中。</p>
<h3 id="HandlerInterceptor-处理器拦截器"><a href="#HandlerInterceptor-处理器拦截器" class="headerlink" title="HandlerInterceptor(处理器拦截器)"></a>HandlerInterceptor(处理器拦截器)</h3><h3 id="HandlerExecutionChain-处理器执行链"><a href="#HandlerExecutionChain-处理器执行链" class="headerlink" title="HandlerExecutionChain (处理器执行链)"></a>HandlerExecutionChain (处理器执行链)</h3><p> 它包括一个处理器、多个HandlerInterceptor拦截器</p>
<h3 id="HandlerAdapter-处理器适配器"><a href="#HandlerAdapter-处理器适配器" class="headerlink" title="HandlerAdapter(处理器适配器)"></a>HandlerAdapter(处理器适配器)</h3><p> 调用具体的方法对用户发来的请求来进行处理</p>
<h3 id="ModelAndView-模型和视图"><a href="#ModelAndView-模型和视图" class="headerlink" title="ModelAndView (模型和视图)"></a>ModelAndView (模型和视图)</h3><p>装载了模型数据和视图信息</p>
<h3 id="ViewResolver-（视图解析器）"><a href="#ViewResolver-（视图解析器）" class="headerlink" title="ViewResolver （视图解析器）"></a>ViewResolver （视图解析器）</h3><p>将数据填充到视图中</p>
<h2 id="流程介绍"><a href="#流程介绍" class="headerlink" title="流程介绍"></a>流程介绍</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://img-blog.csdnimg.cn/20200209160301419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><ol>
<li>客户端发送请求,前置控制器(DispatcherServlet)接受请求</li>
<li>前置控制器将请求发送给处理器映射器（HandlerMapping）进行处理，返回一个处理器执行链（HandlerExecutionChain（=（处理器拦截器）HandlerIntercepter+（处理器）Handler））</li>
<li>前置控制器给处理器适配器（HandlerAdapter）发送请求，HandlerAdapter进行处理，执行Handler，返回ModelAndView</li>
<li>前置控制器将返回来的ModelAndView交给视图解析器（ViewResolver）进行解析，返回一个填充了数据的视图</li>
<li>最后将得来的视图返回给客服端做响应</li>
</ol>
]]></content>
      <categories>
        <category>Java框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap实现原理</title>
    <url>/2020/02/16/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a>HashMap实现原理</h1><a id="more"></a>

<h2 id="JDK1-7HashMap（提一下，后面就不提了）"><a href="#JDK1-7HashMap（提一下，后面就不提了）" class="headerlink" title="JDK1.7HashMap（提一下，后面就不提了）"></a>JDK1.7HashMap（提一下，后面就不提了）</h2><p>JDK1.7HashMap底层是由数组加链表的形式组成</p>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p><img src="https://img-blog.csdnimg.cn/20200208201604467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="JDK1-8HashMap"><a href="#JDK1-8HashMap" class="headerlink" title="JDK1.8HashMap"></a>JDK1.8HashMap</h2><p>JDK1.8HashMap底层是由数组加链表以及红黑树实现的</p>
<h3 id="模型-1"><a href="#模型-1" class="headerlink" title="模型"></a>模型</h3><p><img src="https://img-blog.csdnimg.cn/20200210150204327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="HashMap常见的变量"><a href="#HashMap常见的变量" class="headerlink" title="HashMap常见的变量"></a>HashMap常见的变量</h2><h3 id="默认大小"><a href="#默认大小" class="headerlink" title="默认大小"></a>默认大小</h3><p>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</p>
<p>HashMap底层是由数组组成，初始大小为16，也可以自己设置初始大小，推荐使用2的幂数，就算没啥用，HashMap也会帮我们自动变更为最接近的2的幂数倍</p>
<h3 id="最大容量"><a href="#最大容量" class="headerlink" title="最大容量"></a>最大容量</h3><p>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</p>
<p>HashMap最大容量为2的30幂</p>
<h3 id="扩容因子"><a href="#扩容因子" class="headerlink" title="扩容因子"></a>扩容因子</h3><p>static final float DEFAULT_LOAD_FACTOR = 0.75f;</p>
<p>HashMap默认的扩容因子为0.75f，也可以自己设置扩容因子</p>
<h4 id="为什么扩容因子设置为0-75f"><a href="#为什么扩容因子设置为0-75f" class="headerlink" title="为什么扩容因子设置为0.75f"></a>为什么扩容因子设置为0.75f</h4><ol>
<li>根据泊松分布，0.75的空间利用和查询时间消耗都是最优的</li>
<li>如果扩容因子为1的话，这样空间利用是最好的，但是查询的时间大大提高了，并且hash碰撞的次数变多了。</li>
<li>如果扩容因子为0.5的话，这样查询的时间大大减少了，但是空间利用就浪费了很多，并且rehash的次数变多了。</li>
</ol>
<h3 id="链表转红黑树"><a href="#链表转红黑树" class="headerlink" title="链表转红黑树"></a>链表转红黑树</h3><p>static final int TREEIFY_THRESHOLD = 8;</p>
<p>当链表长度为8后，链表会转为红黑树（长度为8时，还是用链表存储，从第9个元素才会开始重新用红黑树存储，）</p>
<h4 id="为什么链表长度为8转成红黑树"><a href="#为什么链表长度为8转成红黑树" class="headerlink" title="为什么链表长度为8转成红黑树"></a>为什么链表长度为8转成红黑树</h4><p>因为节点的发布会遵守泊松发布，一个链表长度为8的时候，发生hash碰撞的机会基本为0，（默认扩容因子的情况下）</p>
<h3 id="链表转红黑树需求"><a href="#链表转红黑树需求" class="headerlink" title="链表转红黑树需求"></a>链表转红黑树需求</h3><p>static final int MIN_TREEIFY_CAPACITY = 64;</p>
<p>只有当桶的长度为64及以上，才会转红黑树，否则，就算，链表长度大于8了，还是以链表形式存储</p>
<h3 id="红黑树转链表"><a href="#红黑树转链表" class="headerlink" title="红黑树转链表"></a>红黑树转链表</h3><p>static final int UNTREEIFY_THRESHOLD = 6;</p>
<p>当红黑树元素个数少于6个的时候才会转链表（个数为6的时候还是红黑树，为5的时候才开始重新用链表存储）</p>
<h2 id="HashMap存储方式"><a href="#HashMap存储方式" class="headerlink" title="HashMap存储方式"></a>HashMap存储方式</h2><h3 id="Node-lt-K-V-gt-类"><a href="#Node-lt-K-V-gt-类" class="headerlink" title="Node&lt;K,V&gt; 类"></a>Node&lt;K,V&gt; 类</h3><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">      <span class="keyword">final</span> K key;</span><br><span class="line">      V value;</span><br><span class="line">      Node&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure>

<h4 id="hash值"><a href="#hash值" class="headerlink" title="hash值"></a>hash值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>获取这个类对象变量key的值，如果这个键为空，则这个Enrty的hash值为0<br>如果键不为空，则hash值为键的hashcode值异或上h&gt;&gt;&gt;16(h取出高16位)（解释&gt;&gt;&gt;:无符号右移16个位置）</p>
<h4 id="next"><a href="#next" class="headerlink" title="next"></a>next</h4><p>因为是用链表实现的，所以next是用来存储下标相同但hash值不同的Entry</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="HashCode"><a href="#HashCode" class="headerlink" title="HashCode"></a>HashCode</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>存储对象的hashcode值由键的hashcode值异或上值的hashcode值</p>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>首先判断传入对象和当前hashmap内存地址是否一样，如果一样就返回true，如果不一样在判断，传入对象是否被包含在当前hashmap类，如果在就判断，key和value值是否相等，如果相等返回true，否则就返回false</p>
<h2 id="HashMap构造方法"><a href="#HashMap构造方法" class="headerlink" title="HashMap构造方法"></a>HashMap构造方法</h2><h3 id="无参构造方法"><a href="#无参构造方法" class="headerlink" title="无参构造方法"></a>无参构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment">     * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>用默认的初始容量构造一个空的HashMap（16）和默认荷载系数（0.75）。</p>
<h3 id="一个参数构造方法"><a href="#一个参数构造方法" class="headerlink" title="一个参数构造方法"></a>一个参数构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用两个参数的构造方法，将扩容因子设置为默认扩容因子</p>
<h3 id="两个参数构造方法"><a href="#两个参数构造方法" class="headerlink" title="两个参数构造方法"></a>两个参数构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity and load factor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">     *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap的添加方法"><a href="#HashMap的添加方法" class="headerlink" title="HashMap的添加方法"></a>HashMap的添加方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//调用putVal方法（传入五个参数）</span></span><br><span class="line">      <span class="comment">//key的hash值，</span></span><br><span class="line">      <span class="comment">//key，</span></span><br><span class="line">      <span class="comment">//value，</span></span><br><span class="line">      <span class="comment">//是否是创建模式</span></span><br><span class="line">      <span class="comment">//是否允许linkedhashmap后置操作</span></span><br><span class="line">      <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//tab 哈希数组，p 该哈希桶的首节点，n hashMap的长度，i 计算出的数组下标</span></span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">      <span class="comment">//判断table是否加载过，如果没有就进行加载，默认table是懒加载，需要put才能初始化，</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">          n = (tab = resize()).length;</span><br><span class="line">      <span class="comment">//判断当前位置是否为空，如果为空，就把key-value存储到这个位置</span></span><br><span class="line">      <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">          tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">//该位置已经有值，发送了hash碰撞</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// e 临时节点的作用， k 存放该当前节点的key</span></span><br><span class="line">          Node&lt;K,V&gt; e; K k;</span><br><span class="line">          <span class="comment">//判断插入的节点hash值和当前节点的hash值是否相等，已经key是否为空，相等，则进行覆盖</span></span><br><span class="line">          <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">              ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              e = p;</span><br><span class="line">          <span class="comment">//如果不是首节点，则判断p是不是红黑树的节点</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">              <span class="comment">//如果是节点，则判断该节点是否存在，如果已经存在就覆盖，不存在就往后添加</span></span><br><span class="line">              e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">          <span class="comment">//第三种，不是首节点，也不是红黑树节点，则为链表的节点</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//for循环进行遍历</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                  <span class="comment">//如果找到最后一个节点都没找到，则往后添加</span></span><br><span class="line">                  <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                      <span class="comment">//判断是否转为红黑树</span></span><br><span class="line">                      <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                          treeifyBin(tab, hash);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//如果找到了，则覆盖</span></span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  p = e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//有重复的key，则用待插入值进行覆盖，返回旧值。</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">              V oldValue = e.value;</span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                  e.value = value;</span><br><span class="line">              afterNodeAccess(e);</span><br><span class="line">              <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//到了此步骤，则表明待插入的key-value是没有key的重复，因为插入成功e节点的值为null</span></span><br><span class="line">      <span class="comment">//修改次数+1</span></span><br><span class="line">      ++modCount;</span><br><span class="line">        <span class="comment">//实际长度+1，判断是否大于临界值，大于则扩容</span></span><br><span class="line">      <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">          resize();</span><br><span class="line">      <span class="comment">//允许linkedhashmap后置操作</span></span><br><span class="line">      afterNodeInsertion(evict);</span><br><span class="line">      <span class="comment">//操作成功</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先判断插入的key值是否为空，如果为空，因为HashMap允许存入空值，但是只能存储一个key为空的值，这个key-value存储到下标为0的位置</li>
<li>如果key不为空，就放到数组中，用hash值寻找下标，如果该位置为空，则在该位置添加该key-value</li>
<li>如果该位置有值了，则发生了hash碰撞，需要先去红黑树中寻找，遍历，看是否为红黑树中的节点，如果存在，并且key也相等，则覆盖值</li>
<li>如果红黑树中也没有，则去链表中遍历寻找，找到了与之相等的节点以及key相等，则覆盖</li>
<li>如果没有找到，则在链表后面添加该key-value值</li>
</ol>
<h2 id="HashMap的查询方法"><a href="#HashMap的查询方法" class="headerlink" title="HashMap的查询方法"></a>HashMap的查询方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//数组 tab    中间节点first   ，长度    ，key</span></span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">       <span class="comment">//判断tab是否为空，长度是否大于0，当前节点是否存在值</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//判断该位置第一个节点的hash值，key是否相等，如果相等就返回节点</span></span><br><span class="line">           <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">               ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               <span class="keyword">return</span> first;</span><br><span class="line">           <span class="comment">//判断当前位置节点是否有下一个节点</span></span><br><span class="line">           <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//有下一个节点，判断该节点是否属于红黑树</span></span><br><span class="line">               <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   <span class="comment">//属于就返回接单</span></span><br><span class="line">                   <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">               <span class="comment">//如果不是红黑树，是链表就遍历循环</span></span><br><span class="line">               <span class="keyword">do</span> &#123;</span><br><span class="line">                   <span class="comment">//找到了就返回节点</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">return</span> e;</span><br><span class="line"></span><br><span class="line">               &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//没有就返回null</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果key为空，则看看数组下标为0的key是否为空，如果为空就返回下标为0位置的value，如果不为零就返回null</li>
<li>如果key不为空，先去数组里面遍历查找，如果存在就返回value</li>
<li>如果数组里没有，就去红黑树里查找，判断该节点是否属于红黑树，如果有就返回value</li>
<li>如果红黑树里也没有，就去链表中遍历查询，如果有就返回value</li>
<li>如果链表中也没有，就返回null</li>
</ol>
<h2 id="HashMap的扩容方法"><a href="#HashMap的扩容方法" class="headerlink" title="HashMap的扩容方法"></a>HashMap的扩容方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        <span class="comment">//数组，存放需要扩容的数组</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="comment">//老数组的容量，如果数组不存在，就设置为0，</span></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="comment">//初始化新的容量以及临界值</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断老容量是否大于0</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//判断老容量是否大于等于最大容量</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">//如果大于了，则设置容量为最大容量</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="comment">//返回出去</span></span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置新容量为老容量*2并且是否小于最大容量，老容量是否大于等于默认容量</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                <span class="comment">//设置新的临界值为上一次的2倍</span></span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断老的临界值是否大于0；</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            <span class="comment">//大于0，设置新的容量为老的临界值</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            <span class="comment">//小于0</span></span><br><span class="line">            <span class="comment">//新的容量为默认容量</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            <span class="comment">//新的临界值为默认大小*扩容因子</span></span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果新的临界值为0</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//则设置临界值为新的容量*扩容因子</span></span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置值为临界值</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        <span class="comment">//赋予当前数组</span></span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="comment">//如果老的数组不为空</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                <span class="comment">//临时遍历</span></span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="comment">//设置临时遍历值，且不为空</span></span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//设置老数组中当前位置为空</span></span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//判断当前节点是否有下一个节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">//没有则当前位置填入该节点</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="comment">//如果当前节点有下一个节点，</span></span><br><span class="line">                    <span class="comment">//判断该节点是否属于红黑树，也就是存在哈希冲突，该哈希桶中有多个元素</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">//将此树进行转移到新的数组中</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        <span class="comment">//否则表示为链表，将链表转移到新的数组中</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回新的数组</span></span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先判断老容量是否为0，如果为0，初始化数组，用默认的大小以及扩容因子</li>
<li>如果不为0就判断老容量的值是否为最大的容量，如果是，就返回默认的最大容量</li>
<li>如果不是，就扩容，将原有的数组大小扩容至2倍，</li>
<li>扩容结束后，将原有的数组，重新hash计算小标后转入新的数组中，链表和红黑树跟着数组走</li>
</ol>
<h2 id="HashMap的删除方法"><a href="#HashMap的删除方法" class="headerlink" title="HashMap的删除方法"></a>HashMap的删除方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//tab 哈希数组  ,数组下标的节点 ，tab的长度，下标</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">        <span class="comment">//设置tab，n，p，index的值</span></span><br><span class="line">        <span class="comment">//哈希数组不为null，且长度大于0，然后获得到要删除key的节点所在是数组下标位置</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//临时变量</span></span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            <span class="comment">//判断hash值和key值是否相等，如果相等，则把该下标的节点赋值给node</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="comment">//如果p有下一节点，则代表是红黑树或者链表，头节点不是的话，在红黑树或者链表在查找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//判断p节点是否属于红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//属于, 就把该节点赋值给node</span></span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//遍历链表</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">//判断链表中的节点是否和e节点相等，</span></span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            <span class="comment">//如果相等，则把e的节点值赋值给node</span></span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//循环查找下一节点，知道没有下一节点</span></span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果找到了节点，就开始删除</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="comment">//如果节点属于红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//从红黑树中删除，</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                <span class="comment">//如果是链表，头元素，直接让下一个节点元素覆盖这个头元素</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//是链表但不是头元素，则让下一个节点元素覆盖本节点，下一节点为空，则代表，本节点为空</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                <span class="comment">//操作次数+1</span></span><br><span class="line">                ++modCount;</span><br><span class="line">                <span class="comment">//数组大小-1</span></span><br><span class="line">                --size;</span><br><span class="line">                <span class="comment">//此方法在hashMap中是为了让子类去实现，主要是对删除结点后的链表关系进行处理</span></span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="comment">//返回该节点</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果key为空的话，先判断下标为0位置的key值是否为空，如果为空则删除，否则相反</li>
<li>如果key不为空的话，先循环数组，判断头元素中是否有改key值相等，如果有，则判断其hash值是否相等，如果相等就删除</li>
<li>如果头元素中没有，就去红黑树中查找，如果红黑树中有该节点，则删除本节点，然后进行左旋或者右旋实现树的平衡</li>
<li>如果红黑树也没有则去链表中查找，如果查找到了，则删除</li>
<li>如果没有查找到，则返回null</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java操作RabbitMQ队列</title>
    <url>/2020/02/16/Java%E6%93%8D%E4%BD%9CRabbitMQ%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="Java操作RabbitMQ队列"><a href="#Java操作RabbitMQ队列" class="headerlink" title="Java操作RabbitMQ队列"></a>Java操作RabbitMQ队列</h1><a id="more"></a>

<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="maven配置"><a href="#maven配置" class="headerlink" title="maven配置"></a>maven配置</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">      &lt;!-- 引入队列依赖 --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;4.0.2&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;1.7.10&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;1.7.5&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h2 id="工具类RabbitMQConnectionUtils"><a href="#工具类RabbitMQConnectionUtils" class="headerlink" title="工具类RabbitMQConnectionUtils"></a>工具类RabbitMQConnectionUtils</h2><p>链接RabbitMQ</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//链接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置服务地址</span></span><br><span class="line">        factory.setHost(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        <span class="comment">//设置端口</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//设置vhost</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">"/vhost"</span>);</span><br><span class="line">        <span class="comment">//设置用户名</span></span><br><span class="line">        factory.setUsername(<span class="string">"victoria"</span>);</span><br><span class="line">        <span class="comment">//设置密码</span></span><br><span class="line">        factory.setPassword(<span class="string">"123"</span>);</span><br><span class="line">        <span class="keyword">return</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单队列（Simple-Queue）"><a href="#简单队列（Simple-Queue）" class="headerlink" title="简单队列（Simple Queue）"></a>简单队列（Simple Queue）</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>即简单的点对点消息模型。开启mq服务，开启进程P 生产者向mq 写消息，进程C消费者监听mq，消费消息。<br><img src="https://img-blog.csdnimg.cn/20200205154000615.png" alt="在这里插入图片描述"></p>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"test_simple_queue"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//从链接中获取一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//创建队列声明</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        String msg_str = <span class="string">"hello simple !"</span>;</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,msg_str.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"--send simple"</span>+msg_str);</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"test_simple_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//从链接中获取一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//队列声明</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//定义一个消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"---new recv"</span> + <span class="keyword">new</span> String(body, <span class="string">"utf-8"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单队列不足"><a href="#简单队列不足" class="headerlink" title="简单队列不足"></a>简单队列不足</h3><p>耦合度高，生产者和消费者一一对应，如果想有多个消费者消费队列就不可能了。如果队列名变更，消费者和生产者需要同时变更</p>
<h2 id="工作队列（Work-Queue）"><a href="#工作队列（Work-Queue）" class="headerlink" title="工作队列（Work Queue）"></a>工作队列（Work Queue）</h2><h3 id="模型-1"><a href="#模型-1" class="headerlink" title="模型"></a>模型</h3><p>  一个生产者P，对应了多个消费者C。这些多个C，消费的消息各自不同，C1和C2 消费的消息，构成所有消息的一个全集。</p>
<p>可以开启C的消费竞争 channel.basicQos(1);C1和C2 能者多劳。<br><img src="https://img-blog.csdnimg.cn/20200205193430530.png" alt="在这里插入图片描述"></p>
<h3 id="循环分发"><a href="#循环分发" class="headerlink" title="循环分发"></a>循环分发</h3><p>无论消费者速度快与慢，消费者都只会完成它所负责的那部分，其它消息即使没有被消费，它也不会去消费</p>
<h4 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"test_work_queue"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//生产者</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">            String str_msg = <span class="string">"hello"</span>+i;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,str_msg.getBytes());</span><br><span class="line">            System.out.println(str_msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭通道</span></span><br><span class="line">        channel.close();</span><br><span class="line">        <span class="comment">//关闭链接</span></span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消费者1"><a href="#消费者1" class="headerlink" title="消费者1"></a>消费者1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">recv1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"test_work_queue"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//定义队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//定义消费者</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"[recv1]+"</span>+<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消费者2"><a href="#消费者2" class="headerlink" title="消费者2"></a>消费者2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"test_work_queue"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//定义队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//定义消费者</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"[recv2]+"</span>+<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="公平分发"><a href="#公平分发" class="headerlink" title="公平分发"></a>公平分发</h3><p>解决了上面循环分发，完成固定消息的问题，解决消息速度快的将多解决消息，</p>
<h4 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h4><p>一次只发布一条消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"test_work_queue"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//一次只发一条消息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//生产者</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">            String str_msg = <span class="string">"hello"</span>+i;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,str_msg.getBytes());</span><br><span class="line">            System.out.println(str_msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭通道</span></span><br><span class="line">        channel.close();</span><br><span class="line">        <span class="comment">//关闭链接</span></span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h4><p>一次只接受一条消息，关闭了自动接受，改为手动接受，给与消息队列ACK值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">recv1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"test_work_queue"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//定义队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//一次只接受一条数据</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//定义消费者</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"[recv1]+"</span>+<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消费者2-1"><a href="#消费者2-1" class="headerlink" title="消费者2"></a>消费者2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"test_work_queue"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//定义队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//一次只接受一条数据</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//定义消费者</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"[recv2]+"</span>+<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h2><h3 id="模型-2"><a href="#模型-2" class="headerlink" title="模型"></a>模型</h3><p><img src="https://img-blog.csdnimg.cn/20200206150124815.png" alt="在这里插入图片描述"></p>
<ol>
<li>一个生产者，多个消费者</li>
<li>每一个消费者都有自己的队列</li>
<li>生产者没有将消息直接放到队列，而是放到了交换机 转发器 (exchange)</li>
<li>每个队列都要绑定到交换机上</li>
<li>生产者发送的消息，经过交换机，到达队列，这样就能实现一个消息被多个消费者实现<h3 id="生产者-3"><a href="#生产者-3" class="headerlink" title="生产者"></a>生产者</h3></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"test_exchange_fanout"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//创建链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"fanout"</span>);</span><br><span class="line">        <span class="comment">//一次只发一条数据</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//生产者</span></span><br><span class="line">        String str_msg = <span class="string">"hello exchange"</span>;</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME,<span class="string">""</span>,<span class="keyword">null</span>,str_msg.getBytes());</span><br><span class="line">        System.out.println(str_msg);</span><br><span class="line">        <span class="comment">//关闭通道</span></span><br><span class="line">        channel.close();</span><br><span class="line">        <span class="comment">//关闭链接</span></span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用订阅模式，只启动生产者是看不到消息在哪里的<img src="https://img-blog.csdnimg.cn/20200206152643955.png" alt="在这里插入图片描述"><br>因为交换机没有存储的能力，RabbitMQ中只有队列有存储的能力<br>这个时候还没有队列绑定到这个交换机</p>
<h3 id="消费者1-1"><a href="#消费者1-1" class="headerlink" title="消费者1"></a>消费者1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">recv1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"test_queue_email"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"test_exchange_fanout"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//定义队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//绑定交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">""</span>);</span><br><span class="line">        <span class="comment">//一次只发一条数据</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//定义消费者</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"[recv1]+"</span>+<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        <span class="keyword">boolean</span> ack = <span class="keyword">false</span>;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,ack,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者2-2"><a href="#消费者2-2" class="headerlink" title="消费者2"></a>消费者2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"test_queue_cms"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"test_exchange_fanout"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//定义队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//绑定交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">""</span>);</span><br><span class="line">        <span class="comment">//一次只发一条数据</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//定义消费者</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"[recv2]+"</span>+<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        <span class="keyword">boolean</span> ack = <span class="keyword">false</span>;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,ack,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行完消费者后可以再交换机那里看到绑定的队列</p>
<p><img src="https://img-blog.csdnimg.cn/20200206152923280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p><img src="https://img-blog.csdnimg.cn/20200206153725350.png" alt="在这里插入图片描述"><br>在订阅模式的基础上添加了路由键，将type改为<strong>direct</strong></p>
<h3 id="生产者-4"><a href="#生产者-4" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME= <span class="string">"test_exchange_direct"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//定义交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"direct"</span>);</span><br><span class="line">        <span class="comment">//一次只能发送一条数据</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//发送的消息</span></span><br><span class="line">        String str_msg = <span class="string">"hello direct"</span>;</span><br><span class="line">        <span class="comment">//定义路由键</span></span><br><span class="line">        String rount_key = <span class="string">"info"</span>;</span><br><span class="line">        <span class="comment">//生产者</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME,rount_key,<span class="keyword">null</span>,str_msg.getBytes());</span><br><span class="line">        System.out.println(str_msg);</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者1-2"><a href="#消费者1-2" class="headerlink" title="消费者1"></a>消费者1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">recv1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"test_queue_recv1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME= <span class="string">"test_exchange_direct"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//定义队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//交换机绑定</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">"error"</span>);</span><br><span class="line">        <span class="comment">//一次只接受一条消息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//消费者</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"[recv1]:"</span> + <span class="keyword">new</span> String(body, <span class="string">"utf-8"</span>));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//手动提交</span></span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        <span class="comment">//手动提交</span></span><br><span class="line">        <span class="keyword">boolean</span> ack = <span class="keyword">false</span>;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,ack,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者2-3"><a href="#消费者2-3" class="headerlink" title="消费者2"></a>消费者2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"test_queue_recv2"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME= <span class="string">"test_exchange_direct"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//定义队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//交换机绑定</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">"error"</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">"info"</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">"warning"</span>);</span><br><span class="line">        <span class="comment">//一次只接受一条消息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//消费者</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"[recv1]:"</span> + <span class="keyword">new</span> String(body, <span class="string">"utf-8"</span>));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//手动提交</span></span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        <span class="comment">//手动提交</span></span><br><span class="line">        <span class="keyword">boolean</span> ack = <span class="keyword">false</span>;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,ack,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>路由模式，只能按照路由键来匹配队列，必须得路由键相同的队列才能获取到消息， 这样对多服务的项目不太友好</p>
<h2 id="主题模式"><a href="#主题模式" class="headerlink" title="主题模式"></a>主题模式</h2><h3 id="模型-3"><a href="#模型-3" class="headerlink" title="模型"></a>模型</h3><p><img src="https://img-blog.csdnimg.cn/20200206162943264.png" alt="在这里插入图片描述"><br>在路由模式的基础上添加了匹配。<br>交换机的type=topic<br>“#”代表一个和多个<br>“*”代表一个</p>
<h3 id="生产者-5"><a href="#生产者-5" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"test_exchange_topic"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//定义交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"topic"</span>);</span><br><span class="line">        <span class="comment">//一次只接受一条消息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//消息</span></span><br><span class="line">        String str_msg = <span class="string">"hello topic"</span>;</span><br><span class="line">        <span class="comment">//路由键</span></span><br><span class="line">        String rount_key = <span class="string">"goods.delete"</span>;</span><br><span class="line">        <span class="comment">//生产者</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME,rount_key,<span class="keyword">null</span>,str_msg.getBytes());</span><br><span class="line">        System.out.println(str_msg);</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者1-3"><a href="#消费者1-3" class="headerlink" title="消费者1"></a>消费者1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">recv1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"test_queue_topic1"</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"test_exchange_topic"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//定义队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//交换机绑定</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">"goods.add"</span>);</span><br><span class="line">        <span class="comment">//一次只接受一条消息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//消费者</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"[recv1]:"</span> + <span class="keyword">new</span> String(body, <span class="string">"utf-8"</span>));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//手动提交</span></span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        <span class="comment">//手动提交</span></span><br><span class="line">        <span class="keyword">boolean</span> ack = <span class="keyword">false</span>;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,ack,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者2-4"><a href="#消费者2-4" class="headerlink" title="消费者2"></a>消费者2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"test_queue_topic2"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"test_exchange_topic"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//定义队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//交换机绑定</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">"goods.#"</span>);</span><br><span class="line">        <span class="comment">//一次只接受一条消息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//消费者</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"[recv2]:"</span> + <span class="keyword">new</span> String(body, <span class="string">"utf-8"</span>));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//手动提交</span></span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        <span class="comment">//手动提交</span></span><br><span class="line">        <span class="keyword">boolean</span> ack = <span class="keyword">false</span>;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,ack,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消息应答与消息持久化"><a href="#消息应答与消息持久化" class="headerlink" title="消息应答与消息持久化"></a>消息应答与消息持久化</h2><h3 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> ack = <span class="keyword">false</span>;</span><br><span class="line">channel.basicConsume(QUEUE_NAME,ack,consumer);</span><br></pre></td></tr></table></figure>
<h4 id="ack-true-（自动应答模式）"><a href="#ack-true-（自动应答模式）" class="headerlink" title="ack = true;（自动应答模式）"></a>ack = true;（自动应答模式）</h4><p>一旦RabbitMQ将消息发送给消费者，RabbitMQ就会从内存中删除这个消息</p>
<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>如果RabbitMQ发送给消费者的过程中，消费者被终止，则这个消息也会从内存中删除</p>
<h4 id="ack-false-（手动应答模式）"><a href="#ack-false-（手动应答模式）" class="headerlink" title="ack = false;（手动应答模式）"></a>ack = false;（手动应答模式）</h4><p>解决了上面自动应答的问题，只有消费者自己给RabbitMQ应答时，RabbitMQ才会从内存中删除消息，如果RabbitMQ发送给消费者的过程中，消费者被终止，则这条消息将会传递给下一个消费者完成</p>
<h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><p>RabbitMQ发送消息的过程中，RabbitMQ挂掉了的问题</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>可以在定义队列时，完成消息持久化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义队列</span></span><br><span class="line"><span class="comment">//消息持久化</span></span><br><span class="line"><span class="keyword">boolean</span> durable = <span class="keyword">true</span>;</span><br><span class="line">channel.queueDeclare(QUEUE_NAME,durable,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>如果设置durable=true；则打开了消息持久化，为false则反之</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>如果消息队列已经存在，则不能改变该队列消息持久化</p>
<h2 id="交换机（exchange）"><a href="#交换机（exchange）" class="headerlink" title="交换机（exchange）"></a>交换机（exchange）</h2><p>一边接受生产者的消息，一边向队列推送消息</p>
<h3 id="交换机处理方式"><a href="#交换机处理方式" class="headerlink" title="交换机处理方式"></a>交换机处理方式</h3><ol>
<li>匿名转发  “”</li>
<li>fanout 不处理路由键</li>
<li>direct 处理路由键</li>
</ol>
<h2 id="RabbitMQ的消息确认机制（事务-confirm）"><a href="#RabbitMQ的消息确认机制（事务-confirm）" class="headerlink" title="RabbitMQ的消息确认机制（事务+confirm）"></a>RabbitMQ的消息确认机制（事务+confirm）</h2><p>在RabbitMQ中我们可以通过持久化数据，解决RabbitMQ服务器异常的数据丢失问题</p>
<p>问题：生产者讲消息发送出去后，消息到底到没到达RabbitMQ服务器，默认的情况是不知道的；</p>
<p>两种方式：<br>    AMQP实现事务机制<br>    Confirm模式</p>
<h3 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h3><p>txSelect：用户将当前channel设置成transation模式<br>txcommit：用于提交事务<br>txrollback：用户回滚事务</p>
<h4 id="生产者-6"><a href="#生产者-6" class="headerlink" title="生产者"></a>生产者</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">txsend</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME= <span class="string">"test_queue_tx"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//一次只能发送一条消息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//事务开始</span></span><br><span class="line">            channel.txSelect();</span><br><span class="line">            String str_msg = <span class="string">"send_tx"</span>;</span><br><span class="line">            <span class="comment">//生产者（发布消息）</span></span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,str_msg.getBytes());</span><br><span class="line">            System.out.println(str_msg);</span><br><span class="line">            <span class="comment">//事务提交</span></span><br><span class="line">            channel.txCommit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"tx_rollback"</span>);</span><br><span class="line">            <span class="comment">//事务回滚</span></span><br><span class="line">            channel.txRollback();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭链接</span></span><br><span class="line">            channel.close();</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">txrecv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME= <span class="string">"test_queue_tx"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//一次只接受一条数据</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//消费者（收取消息）</span></span><br><span class="line">        Consumer consumer  = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"[recv1]"</span>+<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此模式很耗时，降低了RabbitMQ的消息吞吐量</p>
<h3 id="Confirm模式"><a href="#Confirm模式" class="headerlink" title="Confirm模式"></a>Confirm模式</h3><p>好处是能异步发送</p>
<h4 id="开启Confirm模式"><a href="#开启Confirm模式" class="headerlink" title="开启Confirm模式"></a>开启Confirm模式</h4><p> channel.confirmSelect(); </p>
<h4 id="编程模式"><a href="#编程模式" class="headerlink" title="编程模式"></a>编程模式</h4><ol>
<li>普通的 一次只发送一条消息 返回一个  waitForConfirm</li>
<li>批量的 批量的发送消息 返回批量的 waitForConfirm</li>
<li>异步confirm模式 ：提供一个回调方法</li>
</ol>
<h4 id="单条"><a href="#单条" class="headerlink" title="单条"></a>单条</h4><h5 id="生产者-7"><a href="#生产者-7" class="headerlink" title="生产者"></a>生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sendsingle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span>  String QUEUE_NAME = <span class="string">"test_queue_confirm1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//一次只发送一条消息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//开启confirm模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        String str_msg = <span class="string">"hello confirm"</span>;</span><br><span class="line">        <span class="comment">//发布消息（生产者）</span></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,str_msg.getBytes());</span><br><span class="line">        <span class="comment">//判断是否有waitForConfirms</span></span><br><span class="line">        <span class="comment">//有则代表发布消息成功，否则反之</span></span><br><span class="line">        <span class="keyword">if</span>(channel.waitForConfirms())&#123;</span><br><span class="line">            System.out.println(<span class="string">"send confirm ok"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"send confirm error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭链接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="消费者-3"><a href="#消费者-3" class="headerlink" title="消费者"></a>消费者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">recvsingle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span>  String QUEUE_NAME = <span class="string">"test_queue_confirm1"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//一次只接受一条消息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//接受消息（消费者）</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"[recv1]-&gt;"</span>+<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="批量"><a href="#批量" class="headerlink" title="批量"></a>批量</h4><h5 id="生产者-8"><a href="#生产者-8" class="headerlink" title="生产者"></a>生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sendbatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span>  String QUEUE_NAME = <span class="string">"test_queue_confirm2"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//一次只发送一条消息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//开启confirm模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        String str_msg = <span class="string">"hello confirm batch!"</span>;</span><br><span class="line">        <span class="comment">//批量发布消息（生产者）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,str_msg.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否有waitForConfirms</span></span><br><span class="line">        <span class="comment">//有则代表发布消息成功，否则反之</span></span><br><span class="line">        <span class="keyword">if</span>(channel.waitForConfirms())&#123;</span><br><span class="line">            System.out.println(<span class="string">"send confirm ok"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"send confirm error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭链接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="消费者-4"><a href="#消费者-4" class="headerlink" title="消费者"></a>消费者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">recvbatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span>  String QUEUE_NAME = <span class="string">"test_queue_confirm2"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//一次只接受一条消息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//接受消息（消费者）</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"[recv1]-&gt;"</span>+<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>Channel对象提供的ConfirmListener0回调方法只包含deliveryTag (当前Chanel发出的消息序号)，我们需要自己为每一个Channel维护一个unconfirm的消息序号集合，每publish 一条数据，集合中元素加1，每回调一次handleAck方法，unconfirm集合删掉<br>相应的一条(multiple=false) 或多条(multiple=true) 记录。从程序运行效率上看，这个unconfirm集合最好采用有序集合SortedSet存储结构。</p>
<h5 id="生产者-9"><a href="#生产者-9" class="headerlink" title="生产者"></a>生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConfirmListener;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.SortedSet;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sendasyn</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"test_queue_confirm3"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connetion = ConnectionUtils.getConnection();</span><br><span class="line">        Channel channel = connetion.createChannel();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//生产者调用confirmselect将channel 设置为conf1xm模式</span></span><br><span class="line">        <span class="comment">//注意confirm模式跟事务机制不能在同一个队列中</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">//未确认的消息标识</span></span><br><span class="line">        <span class="keyword">final</span> SortedSet&lt;Long&gt; confirmSet = Collections.synchronizedSortedSet(<span class="keyword">new</span> TreeSet&lt;Long&gt;());</span><br><span class="line">        channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 处理返回确认成功</span></span><br><span class="line"><span class="comment">             * @param deliveryTag 如果是多条，这个就是最后一条消息的tag</span></span><br><span class="line"><span class="comment">             * @param multiple 是否多条</span></span><br><span class="line"><span class="comment">             * @throws IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> l, <span class="keyword">boolean</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(b)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"----handleAck----multip1e"</span>);</span><br><span class="line">                    confirmSet.headSet(l+<span class="number">1</span>).clear();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"----handleAck----multip1e false"</span>);</span><br><span class="line">                    confirmSet.remove(l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 处理返回确认失败</span></span><br><span class="line"><span class="comment">             * @param deliveryTag 如果是多条，这个就是最后一条消息的tag</span></span><br><span class="line"><span class="comment">             * @param multiple 是否多条</span></span><br><span class="line"><span class="comment">             * @throws IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> l, <span class="keyword">boolean</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(b)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"----handleNack----multip1e"</span>);</span><br><span class="line">                    confirmSet.headSet(l+<span class="number">1</span>).clear();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"----handleNack----multip1e false"</span>);</span><br><span class="line">                    confirmSet.remove(l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        String msg = <span class="string">"hello confirm message!"</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">long</span> seqNo = channel.getNextPublishSeqNo();</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">            confirmSet.add(seqNo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="消费者-5"><a href="#消费者-5" class="headerlink" title="消费者"></a>消费者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">recvasyn</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span>  String QUEUE_NAME = <span class="string">"test_queue_confirm3"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//一次只接受一条消息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//接受消息（消费者）</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"[recv3]-&gt;"</span>+<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="return消息机制"><a href="#return消息机制" class="headerlink" title="return消息机制"></a>return消息机制</h2><h3 id="returnAPI"><a href="#returnAPI" class="headerlink" title="returnAPI"></a>returnAPI</h3><p>basicPublish方法的参数mandatory<br>如果设置mandatory 为true时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么RabbitMQ 会调用Basic.Return 命令将消息返回给生产者。<br>当mandatory参数设置为false 时，出现上述情形，则消息直接被丢弃；</p>
<h3 id="生产者-10"><a href="#生产者-10" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.AMQP;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ReturnListener;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sendreturn</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"test_exchange_return"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//一次只发送一条消息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//路由键名</span></span><br><span class="line">        String rount_key = <span class="string">"useaar.add"</span>;</span><br><span class="line">        String str_msg = <span class="string">"Hello exchange return"</span>;</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME,rount_key,<span class="keyword">true</span>,<span class="keyword">null</span>,str_msg.getBytes());</span><br><span class="line">        <span class="comment">//return消息机制监听</span></span><br><span class="line">        channel.addReturnListener(<span class="keyword">new</span> ReturnListener() &#123;</span><br><span class="line">            <span class="comment">//消息没到达执行的方法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturn</span><span class="params">(<span class="keyword">int</span> i, String s, String s1, String s2, AMQP.BasicProperties basicProperties, <span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"----------return ---------"</span>);</span><br><span class="line">                <span class="comment">//参数一：相应码</span></span><br><span class="line">                System.out.println(i);</span><br><span class="line">                <span class="comment">//参数二：文本</span></span><br><span class="line">                System.out.println(s);</span><br><span class="line">                <span class="comment">//参数三：交换机名</span></span><br><span class="line">                System.out.println(s1);</span><br><span class="line">                <span class="comment">//参数四：路由键名</span></span><br><span class="line">                System.out.println(s2);</span><br><span class="line">                <span class="comment">//参数五:basicProperties</span></span><br><span class="line">                System.out.println(basicProperties);</span><br><span class="line">                <span class="comment">//参数流：传递的消息</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者-6"><a href="#消费者-6" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.victoria.rabbitmq.util.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">recvreturn</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"test_queue_return"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"test_exchange_return"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取链接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//一次只接受一条消息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"topic"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//路由键匹配</span></span><br><span class="line">        String rount_key = <span class="string">"user.#"</span>;</span><br><span class="line">        <span class="comment">//队列绑定交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,rount_key);</span><br><span class="line">        <span class="comment">//消息接收（消费者）</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java高级</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ用户和virtual hosts的添加以及授权</title>
    <url>/2020/02/16/RabbitMQ%E7%94%A8%E6%88%B7%E5%92%8Cvirtual-hosts%E7%9A%84%E6%B7%BB%E5%8A%A0%E4%BB%A5%E5%8F%8A%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<h1 id="RabbitMQ的使用"><a href="#RabbitMQ的使用" class="headerlink" title="RabbitMQ的使用"></a>RabbitMQ的使用</h1><a id="more"></a>

<h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><p>1、超级管理员(administrator)</p>
<p>可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</p>
<p>2、监控者(monitoring)</p>
<p>可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</p>
<p>3、策略制定者(policymaker)</p>
<p>可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。</p>
<p>4、普通管理者(management)</p>
<p>仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</p>
<p>5、其他</p>
<p>无法登陆管理控制台，通常就是普通的生产者和消费者。</p>
<h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p>点击Admin<br><img src="https://img-blog.csdnimg.cn/20200205125023875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>再点击 Add a user<br><img src="https://img-blog.csdnimg.cn/20200205125126531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="添加完成如下"><a href="#添加完成如下" class="headerlink" title="添加完成如下"></a>添加完成如下</h3><p><img src="https://img-blog.csdnimg.cn/20200205125233290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="virtual-hosts管理"><a href="#virtual-hosts管理" class="headerlink" title="virtual hosts管理"></a>virtual hosts管理</h2><p>虚拟主机（vhost）提供逻辑分组和资源分离。每一个vhost本质上是一个mini版的RabbitMQ服务器，拥有自己的connection、exchange、queue、binding等，拥有自己的权限。vhost之于RabbitMQ就像虚拟机于物理机一样，他们通过在各个实例间提供逻辑上分离，允许为不同的应用程序安全保密的运行数据。（大致相当于数据库）</p>
<h3 id="添加virtual-hosts"><a href="#添加virtual-hosts" class="headerlink" title="添加virtual hosts"></a>添加virtual hosts</h3><p><img src="https://img-blog.csdnimg.cn/2020020512545565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200205125513941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="添加成功"><a href="#添加成功" class="headerlink" title="添加成功"></a>添加成功</h3><p><img src="https://img-blog.csdnimg.cn/20200205125702176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>一般以斜杠开头</strong></p>
<h3 id="virtual-hosts授权"><a href="#virtual-hosts授权" class="headerlink" title="virtual hosts授权"></a>virtual hosts授权</h3><p>点击刚刚创建的virtual hosts<br><img src="https://img-blog.csdnimg.cn/20200205125842530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200205125925841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>输入你需要哪个用户可以访问</p>
<p>成功授权后<br><img src="https://img-blog.csdnimg.cn/20200205130016316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Rabbit下载以及安装</title>
    <url>/2020/02/16/Rabbit%E4%B8%8B%E8%BD%BD%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="RabbitMQ介绍"><a href="#RabbitMQ介绍" class="headerlink" title="RabbitMQ介绍"></a>RabbitMQ介绍</h1><p>RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而集群和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。</p>
<a id="more"></a>

<h1 id="RabbitMQ下载"><a href="#RabbitMQ下载" class="headerlink" title="RabbitMQ下载"></a>RabbitMQ下载</h1><p>因为RabbitMQ是基于Erlang语言编写，所以下载RabbitMQ需要先安装Erlang</p>
<h2 id="Erlang下载以及安装"><a href="#Erlang下载以及安装" class="headerlink" title="Erlang下载以及安装"></a>Erlang下载以及安装</h2><h3 id="Erlang-下载"><a href="#Erlang-下载" class="headerlink" title="Erlang 下载"></a>Erlang 下载</h3><p>官方网址：<a href="https://www.erlang.org/downloads" target="_blank" rel="noopener">https://www.erlang.org/downloads</a><br>下载版本号 ：Erlang OTP 22.2<br><img src="https://img-blog.csdnimg.cn/20200204220431601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt=""></p>
<h3 id="Erlang安装"><a href="#Erlang安装" class="headerlink" title="Erlang安装"></a>Erlang安装</h3><p>一直下一步即可</p>
<h2 id="RabbitMQ下载以及安装"><a href="#RabbitMQ下载以及安装" class="headerlink" title="RabbitMQ下载以及安装"></a>RabbitMQ下载以及安装</h2><h3 id="RabbitMQ下载-1"><a href="#RabbitMQ下载-1" class="headerlink" title="RabbitMQ下载"></a>RabbitMQ下载</h3><p>下载地址：<a href="https://www.rabbitmq.com/install-windows.html" target="_blank" rel="noopener">https://www.rabbitmq.com/install-windows.html</a><br>版本号：3.8.2<br><img src="https://img-blog.csdnimg.cn/20200204220733250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ安装</h3><p>和Erlang一样，一直下一步即可</p>
<h2 id="启动RabbitMQ服务"><a href="#启动RabbitMQ服务" class="headerlink" title="启动RabbitMQ服务"></a>启动RabbitMQ服务</h2><p>点击开始找到刚刚安装完成的RabbitMQ<br><img src="https://img-blog.csdnimg.cn/20200204220957158.png" alt=""><br>找到中间的<strong>RabbitMQ Command Prompt</strong></p>
<p>输入 <strong>rabbitmq-plugins enable rabbitmq_management</strong>，这样启动了可视化界面的插件</p>
<p>然后启动RabbitMQ即可</p>
<h2 id="浏览器中打开可视化界面"><a href="#浏览器中打开可视化界面" class="headerlink" title="浏览器中打开可视化界面"></a>浏览器中打开可视化界面</h2><p>在浏览器中输入<strong><a href="http://127.0.0.1:15672" target="_blank" rel="noopener">http://127.0.0.1:15672</a></strong>就可以进入RabbitMQ可视化界面</p>
<h2 id="RabbitMQ的登录"><a href="#RabbitMQ的登录" class="headerlink" title="RabbitMQ的登录"></a>RabbitMQ的登录</h2><p><img src="https://img-blog.csdnimg.cn/20200204221515119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>默认账号和密码都是<strong>guest</strong></p>
<h3 id="默认账号和密码登录失败"><a href="#默认账号和密码登录失败" class="headerlink" title="默认账号和密码登录失败"></a>默认账号和密码登录失败</h3><p>（1）找到C:\Users\Administrator的<strong>Appdata</strong>文件夹（该文件夹是隐藏的，需要手动跳出来，自行百度）<br><strong>Appdata</strong>文件夹中有一个<strong>Roaming</strong>文件夹在里面找到<strong>RabbitMQ</strong>文件夹删除<strong>db</strong>文件夹下面的所有文件<br>（2）重新安装RabbitMQ即可</p>
<h2 id="成功页面"><a href="#成功页面" class="headerlink" title="成功页面"></a>成功页面</h2><p><img src="https://img-blog.csdnimg.cn/20200204221551747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0ODc0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>显示这个页面就代表登录成功</p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro整合SpringBoot实现登录认证</title>
    <url>/2020/02/16/Shiro%E6%95%B4%E5%90%88SpringBoot%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h1 id="Shiro整合SpringBoot"><a href="#Shiro整合SpringBoot" class="headerlink" title="Shiro整合SpringBoot"></a>Shiro整合SpringBoot</h1><a id="more"></a>
<h2 id="Shiro以及SpringBoot环境配置"><a href="#Shiro以及SpringBoot环境配置" class="headerlink" title="Shiro以及SpringBoot环境配置"></a>Shiro以及SpringBoot环境配置</h2><h3 id="maven环境配置"><a href="#maven环境配置" class="headerlink" title="maven环境配置"></a>maven环境配置</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--web启动器--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--thymeleaf--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--mybatis-plus--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;3.3.1.tmp&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--lombok--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">	&lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--mysql--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;8.0.11&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;! --jdbc--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--shiro--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="实体类的创建"><a href="#实体类的创建" class="headerlink" title="实体类的创建"></a>实体类的创建</h3><h4 id="User类的创建"><a href="#User类的创建" class="headerlink" title="User类的创建"></a>User类的创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"><span class="keyword">import</span> lombok.experimental.Accessors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jobob</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-01-29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span>(callSuper = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@TableName</span>(<span class="string">"sys_user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableId</span>(value = <span class="string">"id"</span>, type = IdType.AUTO)</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String loginname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String remark;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer deptid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date hiredate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer mgr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer available;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer ordernum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类型[0超级管理员1，管理员，2普通用户]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头像地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String imgpath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String salt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="UserVo的创建"><a href="#UserVo的创建" class="headerlink" title="UserVo的创建"></a>UserVo的创建</h4><h5 id="解释一下Vo"><a href="#解释一下Vo" class="headerlink" title="解释一下Vo"></a>解释一下Vo</h5><p>对实体类的二次封装，封装了一些对改类的额外属性，继承与User模块</p>
<h5 id="UserVo代码块"><a href="#UserVo代码块" class="headerlink" title="UserVo代码块"></a>UserVo代码块</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.victoria.Warehouse.sys.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserVo</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpringBoot的配置"><a href="#SpringBoot的配置" class="headerlink" title="SpringBoot的配置"></a>SpringBoot的配置</h3><h4 id="application-properties中的配置"><a href="#application-properties中的配置" class="headerlink" title="application.properties中的配置"></a>application.properties中的配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.resources.<span class="keyword">static</span>-locations=classpath:/templates/,classpath:/<span class="keyword">static</span>/</span><br><span class="line"></span><br><span class="line">spring.datasource.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span></span>=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql:<span class="comment">//localhost:3306/0520erp?useSSL=false&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=<span class="number">123456</span></span><br></pre></td></tr></table></figure>

<h4 id="application-yml中的配置"><a href="#application-yml中的配置" class="headerlink" title="application.yml中的配置"></a>application.yml中的配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#shiro的配置</span><br><span class="line">shiro:</span><br><span class="line">  #密码加密方式</span><br><span class="line">  hash-algorithm-name: md5</span><br><span class="line">  #散列次数</span><br><span class="line">  hash-iterations: <span class="number">2</span></span><br><span class="line">  #没有认证钱能访问的资源路径</span><br><span class="line">  anon-urls:</span><br><span class="line">    - /index.html*</span><br><span class="line">    - /sys/login*</span><br><span class="line">    - /login/login*</span><br><span class="line">    - /resources<span class="comment">/**</span></span><br><span class="line"><span class="comment">  #登录成功后的路径</span></span><br><span class="line"><span class="comment">  login-url: /index.html</span></span><br><span class="line"><span class="comment">  #退出后的路径</span></span><br><span class="line"><span class="comment">  log-out-url: /login/logout*</span></span><br><span class="line"><span class="comment">  #拦截路径</span></span><br><span class="line"><span class="comment">  authc-ulrs:</span></span><br><span class="line"><span class="comment">    - /**</span></span><br></pre></td></tr></table></figure>

<h4 id="配置合并"><a href="#配置合并" class="headerlink" title="配置合并"></a>配置合并</h4><p>application.properties中的配置可以移到application.yml中，最好移到yml文件中，SpringBoot会最先加载yml文件</p>
<h3 id="Shiro的配置"><a href="#Shiro的配置" class="headerlink" title="Shiro的配置"></a>Shiro的配置</h3><h4 id="ShiroConfig文件"><a href="#ShiroConfig文件" class="headerlink" title="ShiroConfig文件"></a>ShiroConfig文件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> com.victoria.Warehouse.sys.realm.UserRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.credential.CredentialsMatcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.credential.HashedCredentialsMatcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.mgt.SecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.spring.web.ShiroFilterFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.web.mgt.DefaultWebSecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication.Type;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.DelegatingFilterProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>(type = Type.SERVLET)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(value = &#123; SecurityManager<span class="class">.<span class="keyword">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConfigurationProperties</span>(<span class="title">prefix</span> </span>= <span class="string">"shiro"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">shiroConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SHIRO_DIALECT = <span class="string">"shiroDialect"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SHIRO_FILTER = <span class="string">"shiroFilter"</span>;</span><br><span class="line">    <span class="keyword">private</span> String hashAlgorithmName = <span class="string">"md5"</span>;<span class="comment">// 加密方式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hashIterations = <span class="number">2</span>;<span class="comment">// 散列次数</span></span><br><span class="line">    <span class="keyword">private</span> String loginUrl = <span class="string">"/index.html"</span>;<span class="comment">// 默认的登陆页面</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] anonUrls;</span><br><span class="line">    <span class="keyword">private</span> String logOutUrl;</span><br><span class="line">    <span class="keyword">private</span> String[] authcUlrs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明凭证匹配器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"credentialsMatcher"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HashedCredentialsMatcher <span class="title">hashedCredentialsMatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashedCredentialsMatcher credentialsMatcher = <span class="keyword">new</span> HashedCredentialsMatcher();</span><br><span class="line">        credentialsMatcher.setHashAlgorithmName(hashAlgorithmName);</span><br><span class="line">        credentialsMatcher.setHashIterations(hashIterations);</span><br><span class="line">        <span class="keyword">return</span> credentialsMatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明userRealm</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"userRealm"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserRealm <span class="title">userRealm</span><span class="params">(CredentialsMatcher credentialsMatcher)</span> </span>&#123;</span><br><span class="line">        UserRealm userRealm = <span class="keyword">new</span> UserRealm();</span><br><span class="line">        <span class="comment">// 注入凭证匹配器</span></span><br><span class="line">        userRealm.setCredentialsMatcher(credentialsMatcher);</span><br><span class="line">        <span class="keyword">return</span> userRealm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置SecurityManager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"securityManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">(UserRealm userRealm)</span> </span>&#123;</span><br><span class="line">        DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        <span class="comment">// 注入userRealm</span></span><br><span class="line">        securityManager.setRealm(userRealm);</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置shiro的过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(SHIRO_FILTER)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilterFactoryBean</span><span class="params">(SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        ShiroFilterFactoryBean factoryBean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        <span class="comment">// 设置安全管理器</span></span><br><span class="line">        factoryBean.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">// 设置未登陆的时要跳转的页面</span></span><br><span class="line">        factoryBean.setLoginUrl(loginUrl);</span><br><span class="line">        Map&lt;String, String&gt; filterChainDefinitionMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置放行的路径</span></span><br><span class="line">        <span class="keyword">if</span> (anonUrls != <span class="keyword">null</span> &amp;&amp; anonUrls.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String anon : anonUrls) &#123;</span><br><span class="line">                filterChainDefinitionMap.put(anon, <span class="string">"anon"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置登出的路径</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != logOutUrl) &#123;</span><br><span class="line">            filterChainDefinitionMap.put(logOutUrl, <span class="string">"logout"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置拦截的路径</span></span><br><span class="line">        <span class="keyword">if</span> (authcUlrs != <span class="keyword">null</span> &amp;&amp; authcUlrs.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String authc : authcUlrs) &#123;</span><br><span class="line">                filterChainDefinitionMap.put(authc, <span class="string">"authc"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, Filter&gt; filters=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//		filters.put("authc", new ShiroLoginFilter());</span></span><br><span class="line">        <span class="comment">//配置过滤器</span></span><br><span class="line">        factoryBean.setFilters(filters);</span><br><span class="line">        factoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">        <span class="keyword">return</span> factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册shiro的委托过滤器，相当于之前在web.xml里面配置的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean&lt;DelegatingFilterProxy&gt; <span class="title">delegatingFilterProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean&lt;DelegatingFilterProxy&gt; filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean&lt;DelegatingFilterProxy&gt;();</span><br><span class="line">        DelegatingFilterProxy proxy = <span class="keyword">new</span> DelegatingFilterProxy();</span><br><span class="line">        proxy.setTargetFilterLifecycle(<span class="keyword">true</span>);</span><br><span class="line">        proxy.setTargetBeanName(SHIRO_FILTER);</span><br><span class="line">        filterRegistrationBean.setFilter(proxy);</span><br><span class="line">        <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 加入注解的使用，不加入这个注解不生效--开始 */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> securityManager</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title">authorizationAttributeSourceAdvisor</span><span class="params">(SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> authorizationAttributeSourceAdvisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="title">getDefaultAdvisorAutoProxyCreator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = <span class="keyword">new</span> DefaultAdvisorAutoProxyCreator();</span><br><span class="line">        advisorAutoProxyCreator.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> advisorAutoProxyCreator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 加入注解的使用，不加入这个注解不生效--结束 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="UserRealm-java文件"><a href="#UserRealm-java文件" class="headerlink" title="UserRealm.java文件"></a>UserRealm.java文件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.toolkit.StringUtils;</span><br><span class="line"><span class="keyword">import</span> com.victoria.Warehouse.sys.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.victoria.Warehouse.sys.service.IUserService;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.PrincipalCollection;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.ByteSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IUserService iUserService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//认证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="comment">//获取用户名</span></span><br><span class="line">        String loginname = authenticationToken.getPrincipal().toString();</span><br><span class="line">        <span class="comment">//条件</span></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(StringUtils.isNotBlank(loginname),<span class="string">"loginname"</span>,loginname);</span><br><span class="line">        <span class="comment">//查询出来的user对象</span></span><br><span class="line">        User user = iUserService.getOne(queryWrapper);</span><br><span class="line">        <span class="comment">//盐的创建</span></span><br><span class="line">        ByteSource salt = ByteSource.Util.bytes(user.getSalt());</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * SimpleAuthenticationInfo可以有三个参数或者四个参数</span></span><br><span class="line"><span class="comment">        * 三个参数：</span></span><br><span class="line"><span class="comment">        *   1.第一个是对象，可以供授权使用的对象</span></span><br><span class="line"><span class="comment">        *   2.user.pwd，根据用户名查询到的密码，判断密码是否相等用</span></span><br><span class="line"><span class="comment">        *   3.realm名</span></span><br><span class="line"><span class="comment">        * 四个参数：</span></span><br><span class="line"><span class="comment">        *   1.第一个是对象，可以供授权使用的对象</span></span><br><span class="line"><span class="comment">        *   2.user.pwd，根据用户名查询到的密码，判断密码是否相等用</span></span><br><span class="line"><span class="comment">        *   3.盐</span></span><br><span class="line"><span class="comment">        *   4.realm名</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line">        AuthenticationInfo info = <span class="keyword">new</span> SimpleAuthenticationInfo(user,user.getPwd(),salt,<span class="keyword">this</span>.getName());</span><br><span class="line">        <span class="comment">//返回给调用者，是否成功</span></span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//授权</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Controller文件"><a href="#Controller文件" class="headerlink" title="Controller文件"></a>Controller文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.victoria.Warehouse.sys.vo.UserVo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(UserVo userVo)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个subject对象</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">// 把用户名和密码封装为 UsernamePasswordToken 对象</span></span><br><span class="line">        AuthenticationToken token = <span class="keyword">new</span> UsernamePasswordToken(userVo.getLoginname(),userVo.getPwd());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//进行登录认证</span></span><br><span class="line">            subject.login(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"用户名或者密码错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><h4 id="本文只是作者对Shiro代码的总结，避免自己忘记"><a href="#本文只是作者对Shiro代码的总结，避免自己忘记" class="headerlink" title="本文只是作者对Shiro代码的总结，避免自己忘记"></a>本文只是作者对Shiro代码的总结，避免自己忘记</h4>]]></content>
      <categories>
        <category>Java框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Shiro</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
</search>
